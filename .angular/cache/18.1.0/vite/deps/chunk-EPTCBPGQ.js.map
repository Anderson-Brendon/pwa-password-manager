{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/dist/esm/rx-storage-helper.js"],
  "sourcesContent": ["/**\n * Helper functions for accessing the RxStorage instances.\n */\n\nimport { overwritable } from \"./overwritable.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { getPrimaryFieldOfPrimaryKey } from \"./rx-schema-helper.js\";\nimport { PROMISE_RESOLVE_TRUE, RXDB_VERSION, RX_META_LWT_MINIMUM, appendToArray, createRevision, ensureNotFalsy, flatClone, getDefaultRevision, getDefaultRxDocumentMeta, lastOfArray, now, promiseWait, randomCouchString } from \"./plugins/utils/index.js\";\nimport { filter, map, startWith, switchMap } from 'rxjs';\nimport { prepareQuery } from \"./rx-query.js\";\nimport { normalizeMangoQuery } from \"./rx-query-helper.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nexport var INTERNAL_STORAGE_NAME = '_rxdb_internal';\nexport var RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = 'rxdatabase_storage_local';\nexport async function getSingleDocument(storageInstance, documentId) {\n  var results = await storageInstance.findDocumentsById([documentId], false);\n  var doc = results[0];\n  if (doc) {\n    return doc;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Writes a single document,\n * throws RxStorageBulkWriteError on failure\n */\nexport async function writeSingle(instance, writeRow, context) {\n  var writeResult = await instance.bulkWrite([writeRow], context);\n  if (writeResult.error.length > 0) {\n    var error = writeResult.error[0];\n    throw error;\n  } else {\n    var ret = writeResult.success[0];\n    return ret;\n  }\n}\n\n/**\n * Observe the plain document data of a single document.\n * Do not forget to unsubscribe.\n */\nexport function observeSingle(storageInstance, documentId) {\n  var firstFindPromise = getSingleDocument(storageInstance, documentId);\n  var ret = storageInstance.changeStream().pipe(map(evBulk => evBulk.events.find(ev => ev.documentId === documentId)), filter(ev => !!ev), map(ev => Promise.resolve(ensureNotFalsy(ev).documentData)), startWith(firstFindPromise), switchMap(v => v), filter(v => !!v));\n  return ret;\n}\n\n/**\n * Checkpoints must be stackable over another.\n * This is required form some RxStorage implementations\n * like the sharding plugin, where a checkpoint only represents\n * the document state from some, but not all shards.\n */\nexport function stackCheckpoints(checkpoints) {\n  return Object.assign({}, ...checkpoints);\n}\nexport function throwIfIsStorageWriteError(collection, documentId, writeData, error) {\n  if (error) {\n    if (error.status === 409) {\n      throw newRxError('CONFLICT', {\n        collection: collection.name,\n        id: documentId,\n        writeError: error,\n        data: writeData\n      });\n    } else if (error.status === 422) {\n      throw newRxError('VD2', {\n        collection: collection.name,\n        id: documentId,\n        writeError: error,\n        data: writeData\n      });\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Analyzes a list of BulkWriteRows and determines\n * which documents must be inserted, updated or deleted\n * and which events must be emitted and which documents cause a conflict\n * and must not be written.\n * Used as helper inside of some RxStorage implementations.\n * @hotPath The performance of this function is critical\n */\nexport function categorizeBulkWriteRows(storageInstance, primaryPath,\n/**\n * Current state of the documents\n * inside of the storage. Used to determine\n * which writes cause conflicts.\n * This must be a Map for better performance.\n */\ndocsInDb,\n/**\n * The write rows that are passed to\n * RxStorageInstance().bulkWrite().\n */\nbulkWriteRows, context,\n/**\n * Used by some storages for better performance.\n * For example when get-by-id and insert/update can run in parallel.\n */\nonInsert, onUpdate) {\n  var hasAttachments = !!storageInstance.schema.attachments;\n  var bulkInsertDocs = [];\n  var bulkUpdateDocs = [];\n  var errors = [];\n  var eventBulkId = randomCouchString(10);\n  var eventBulk = {\n    id: eventBulkId,\n    events: [],\n    checkpoint: null,\n    context,\n    startTime: now(),\n    endTime: 0\n  };\n  var eventBulkEvents = eventBulk.events;\n  var attachmentsAdd = [];\n  var attachmentsRemove = [];\n  var attachmentsUpdate = [];\n  var hasDocsInDb = docsInDb.size > 0;\n  var newestRow;\n\n  /**\n   * @performance is really important in this loop!\n   */\n  var rowAmount = bulkWriteRows.length;\n  var _loop = function () {\n    var writeRow = bulkWriteRows[rowId];\n\n    // use these variables to have less property accesses\n    var document = writeRow.document;\n    var previous = writeRow.previous;\n    var docId = document[primaryPath];\n    var documentDeleted = document._deleted;\n    var previousDeleted = previous && previous._deleted;\n    var documentInDb = undefined;\n    if (hasDocsInDb) {\n      documentInDb = docsInDb.get(docId);\n    }\n    var attachmentError;\n    if (!documentInDb) {\n      /**\n       * It is possible to insert already deleted documents,\n       * this can happen on replication.\n       */\n      var insertedIsDeleted = documentDeleted ? true : false;\n      if (hasAttachments) {\n        Object.entries(document._attachments).forEach(([attachmentId, attachmentData]) => {\n          if (!attachmentData.data) {\n            attachmentError = {\n              documentId: docId,\n              isError: true,\n              status: 510,\n              writeRow,\n              attachmentId\n            };\n            errors.push(attachmentError);\n          } else {\n            attachmentsAdd.push({\n              documentId: docId,\n              attachmentId,\n              attachmentData: attachmentData,\n              digest: attachmentData.digest\n            });\n          }\n        });\n      }\n      if (!attachmentError) {\n        if (hasAttachments) {\n          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));\n          if (onInsert) {\n            onInsert(document);\n          }\n        } else {\n          bulkInsertDocs.push(writeRow);\n          if (onInsert) {\n            onInsert(document);\n          }\n        }\n        newestRow = writeRow;\n      }\n      if (!insertedIsDeleted) {\n        var event = {\n          documentId: docId,\n          operation: 'INSERT',\n          documentData: hasAttachments ? stripAttachmentsDataFromDocument(document) : document,\n          previousDocumentData: hasAttachments && previous ? stripAttachmentsDataFromDocument(previous) : previous\n        };\n        eventBulkEvents.push(event);\n      }\n    } else {\n      // update existing document\n      var revInDb = documentInDb._rev;\n\n      /**\n       * Check for conflict\n       */\n      if (!previous || !!previous && revInDb !== previous._rev) {\n        // is conflict error\n        var err = {\n          isError: true,\n          status: 409,\n          documentId: docId,\n          writeRow: writeRow,\n          documentInDb\n        };\n        errors.push(err);\n        return 1; // continue\n      }\n\n      // handle attachments data\n\n      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;\n      if (hasAttachments) {\n        if (documentDeleted) {\n          /**\n           * Deleted documents must have cleared all their attachments.\n           */\n          if (previous) {\n            Object.keys(previous._attachments).forEach(attachmentId => {\n              attachmentsRemove.push({\n                documentId: docId,\n                attachmentId,\n                digest: ensureNotFalsy(previous)._attachments[attachmentId].digest\n              });\n            });\n          }\n        } else {\n          // first check for errors\n          Object.entries(document._attachments).find(([attachmentId, attachmentData]) => {\n            var previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n            if (!previousAttachmentData && !attachmentData.data) {\n              attachmentError = {\n                documentId: docId,\n                documentInDb: documentInDb,\n                isError: true,\n                status: 510,\n                writeRow,\n                attachmentId\n              };\n            }\n            return true;\n          });\n          if (!attachmentError) {\n            Object.entries(document._attachments).forEach(([attachmentId, attachmentData]) => {\n              var previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n              if (!previousAttachmentData) {\n                attachmentsAdd.push({\n                  documentId: docId,\n                  attachmentId,\n                  attachmentData: attachmentData,\n                  digest: attachmentData.digest\n                });\n              } else {\n                var newDigest = updatedRow.document._attachments[attachmentId].digest;\n                if (attachmentData.data &&\n                /**\n                 * Performance shortcut,\n                 * do not update the attachment data if it did not change.\n                 */\n                previousAttachmentData.digest !== newDigest) {\n                  attachmentsUpdate.push({\n                    documentId: docId,\n                    attachmentId,\n                    attachmentData: attachmentData,\n                    digest: attachmentData.digest\n                  });\n                }\n              }\n            });\n          }\n        }\n      }\n      if (attachmentError) {\n        errors.push(attachmentError);\n      } else {\n        if (hasAttachments) {\n          bulkUpdateDocs.push(stripAttachmentsDataFromRow(updatedRow));\n          if (onUpdate) {\n            onUpdate(document);\n          }\n        } else {\n          bulkUpdateDocs.push(updatedRow);\n          if (onUpdate) {\n            onUpdate(document);\n          }\n        }\n        newestRow = updatedRow;\n      }\n      var eventDocumentData = null;\n      var previousEventDocumentData = null;\n      var operation = null;\n      if (previousDeleted && !documentDeleted) {\n        operation = 'INSERT';\n        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document;\n      } else if (previous && !previousDeleted && !documentDeleted) {\n        operation = 'UPDATE';\n        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document;\n        previousEventDocumentData = previous;\n      } else if (documentDeleted) {\n        operation = 'DELETE';\n        eventDocumentData = ensureNotFalsy(document);\n        previousEventDocumentData = previous;\n      } else {\n        throw newRxError('SNH', {\n          args: {\n            writeRow\n          }\n        });\n      }\n      var _event = {\n        documentId: docId,\n        documentData: eventDocumentData,\n        previousDocumentData: previousEventDocumentData,\n        operation: operation\n      };\n      eventBulkEvents.push(_event);\n    }\n  };\n  for (var rowId = 0; rowId < rowAmount; rowId++) {\n    if (_loop()) continue;\n  }\n  return {\n    bulkInsertDocs,\n    bulkUpdateDocs,\n    newestRow,\n    errors,\n    eventBulk,\n    attachmentsAdd,\n    attachmentsRemove,\n    attachmentsUpdate\n  };\n}\nexport function stripAttachmentsDataFromRow(writeRow) {\n  return {\n    previous: writeRow.previous,\n    document: stripAttachmentsDataFromDocument(writeRow.document)\n  };\n}\nexport function getAttachmentSize(attachmentBase64String) {\n  return atob(attachmentBase64String).length;\n}\n\n/**\n * Used in custom RxStorage implementations.\n */\nexport function attachmentWriteDataToNormalData(writeData) {\n  var data = writeData.data;\n  if (!data) {\n    return writeData;\n  }\n  var ret = {\n    length: getAttachmentSize(data),\n    digest: writeData.digest,\n    type: writeData.type\n  };\n  return ret;\n}\nexport function stripAttachmentsDataFromDocument(doc) {\n  if (!doc._attachments || Object.keys(doc._attachments).length === 0) {\n    return doc;\n  }\n  var useDoc = flatClone(doc);\n  useDoc._attachments = {};\n  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {\n    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);\n  });\n  return useDoc;\n}\n\n/**\n * Flat clone the document data\n * and also the _meta field.\n * Used many times when we want to change the meta\n * during replication etc.\n */\nexport function flatCloneDocWithMeta(doc) {\n  return Object.assign({}, doc, {\n    _meta: flatClone(doc._meta)\n  });\n}\n/**\n * Wraps the normal storageInstance of a RxCollection\n * to ensure that all access is properly using the hooks\n * and other data transformations and also ensure that database.lockedRun()\n * is used properly.\n */\nexport function getWrappedStorageInstance(database, storageInstance,\n/**\n * The original RxJsonSchema\n * before it was mutated by hooks.\n */\nrxJsonSchema) {\n  overwritable.deepFreezeWhenDevMode(rxJsonSchema);\n  var ret = {\n    originalStorageInstance: storageInstance,\n    schema: storageInstance.schema,\n    internals: storageInstance.internals,\n    collectionName: storageInstance.collectionName,\n    databaseName: storageInstance.databaseName,\n    options: storageInstance.options,\n    bulkWrite(rows, context) {\n      var databaseToken = database.token;\n      var toStorageWriteRows = new Array(rows.length);\n      /**\n       * Use the same timestamp for all docs of this rows-set.\n       * This improves performance because calling Date.now() inside of the now() function\n       * is too costly.\n       */\n      var time = now();\n      for (var index = 0; index < rows.length; index++) {\n        var writeRow = rows[index];\n        var document = flatCloneDocWithMeta(writeRow.document);\n        document._meta.lwt = time;\n\n        /**\n         * Yes we really want to set the revision here.\n         * If you make a plugin that relies on having its own revision\n         * stored into the storage, use this.originalStorageInstance.bulkWrite() instead.\n         */\n        var previous = writeRow.previous;\n        document._rev = createRevision(databaseToken, previous);\n        toStorageWriteRows[index] = {\n          document,\n          previous\n        };\n      }\n      runPluginHooks('preStorageWrite', {\n        storageInstance: this.originalStorageInstance,\n        rows: toStorageWriteRows\n      });\n      return database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context))\n      /**\n       * The RxStorageInstance MUST NOT allow to insert already _deleted documents,\n       * without sending the previous document version.\n       * But for better developer experience, RxDB does allow to re-insert deleted documents.\n       * We do this by automatically fixing the conflict errors for that case\n       * by running another bulkWrite() and merging the results.\n       * @link https://github.com/pubkey/rxdb/pull/3839\n       */.then(writeResult => {\n        var useWriteResult = {\n          error: [],\n          success: writeResult.success.slice(0)\n        };\n        var reInsertErrors = writeResult.error.length === 0 ? [] : writeResult.error.filter(error => {\n          if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && ensureNotFalsy(error.documentInDb)._deleted) {\n            return true;\n          }\n          useWriteResult.error.push(error);\n          return false;\n        });\n        if (reInsertErrors.length > 0) {\n          var reInserts = reInsertErrors.map(error => {\n            return {\n              previous: error.documentInDb,\n              document: Object.assign({}, error.writeRow.document, {\n                _rev: createRevision(database.token, error.documentInDb)\n              })\n            };\n          });\n          return database.lockedRun(() => storageInstance.bulkWrite(reInserts, context)).then(subResult => {\n            appendToArray(useWriteResult.error, subResult.error);\n            appendToArray(useWriteResult.success, subResult.success);\n            return useWriteResult;\n          });\n        }\n        return writeResult;\n      });\n    },\n    query(preparedQuery) {\n      return database.lockedRun(() => storageInstance.query(preparedQuery));\n    },\n    count(preparedQuery) {\n      return database.lockedRun(() => storageInstance.count(preparedQuery));\n    },\n    findDocumentsById(ids, deleted) {\n      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));\n    },\n    getAttachmentData(documentId, attachmentId, digest) {\n      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));\n    },\n    getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : (limit, checkpoint) => {\n      return database.lockedRun(() => storageInstance.getChangedDocumentsSince(ensureNotFalsy(limit), checkpoint));\n    },\n    cleanup(minDeletedTime) {\n      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));\n    },\n    remove() {\n      database.storageInstances.delete(ret);\n      return database.lockedRun(() => storageInstance.remove());\n    },\n    close() {\n      database.storageInstances.delete(ret);\n      return database.lockedRun(() => storageInstance.close());\n    },\n    changeStream() {\n      return storageInstance.changeStream();\n    },\n    conflictResultionTasks() {\n      return storageInstance.conflictResultionTasks();\n    },\n    resolveConflictResultionTask(taskSolution) {\n      if (taskSolution.output.isEqual) {\n        return storageInstance.resolveConflictResultionTask(taskSolution);\n      }\n      var doc = Object.assign({}, taskSolution.output.documentData, {\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n      });\n      var documentData = flatClone(doc);\n      delete documentData._meta;\n      delete documentData._rev;\n      delete documentData._attachments;\n      return storageInstance.resolveConflictResultionTask({\n        id: taskSolution.id,\n        output: {\n          isEqual: false,\n          documentData\n        }\n      });\n    }\n  };\n  database.storageInstances.add(ret);\n  return ret;\n}\n\n/**\n * Each RxStorage implementation should\n * run this method at the first step of createStorageInstance()\n * to ensure that the configuration is correct.\n */\nexport function ensureRxStorageInstanceParamsAreCorrect(params) {\n  if (params.schema.keyCompression) {\n    throw newRxError('UT5', {\n      args: {\n        params\n      }\n    });\n  }\n  if (hasEncryption(params.schema)) {\n    throw newRxError('UT6', {\n      args: {\n        params\n      }\n    });\n  }\n  if (params.schema.attachments && params.schema.attachments.compression) {\n    throw newRxError('UT7', {\n      args: {\n        params\n      }\n    });\n  }\n}\nexport function hasEncryption(jsonSchema) {\n  if (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0 || jsonSchema.attachments && jsonSchema.attachments.encrypted) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function getChangedDocumentsSinceQuery(storageInstance, limit, checkpoint) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n  var sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n  var sinceId = checkpoint ? checkpoint.id : '';\n  return normalizeMangoQuery(storageInstance.schema, {\n    selector: {\n      $or: [{\n        '_meta.lwt': {\n          $gt: sinceLwt\n        }\n      }, {\n        '_meta.lwt': {\n          $eq: sinceLwt\n        },\n        [primaryPath]: {\n          $gt: checkpoint ? sinceId : ''\n        }\n      }],\n      // add this hint for better index usage\n      '_meta.lwt': {\n        $gte: sinceLwt\n      }\n    },\n    sort: [{\n      '_meta.lwt': 'asc'\n    }, {\n      [primaryPath]: 'asc'\n    }],\n    skip: 0,\n    limit\n    /**\n     * DO NOT SET A SPECIFIC INDEX HERE!\n     * The query might be modified by some plugin\n     * before sending it to the storage.\n     * We can be sure that in the end the query planner\n     * will find the best index.\n     */\n    // index: ['_meta.lwt', primaryPath]\n  });\n}\nexport async function getChangedDocumentsSince(storageInstance, limit, checkpoint) {\n  if (storageInstance.getChangedDocumentsSince) {\n    return storageInstance.getChangedDocumentsSince(limit, checkpoint);\n  }\n  var primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n  var query = prepareQuery(storageInstance.schema, getChangedDocumentsSinceQuery(storageInstance, limit, checkpoint));\n  var result = await storageInstance.query(query);\n  var documents = result.documents;\n  var lastDoc = lastOfArray(documents);\n  return {\n    documents: documents,\n    checkpoint: lastDoc ? {\n      id: lastDoc[primaryPath],\n      lwt: lastDoc._meta.lwt\n    } : checkpoint ? checkpoint : {\n      id: '',\n      lwt: 0\n    }\n  };\n}\n\n/**\n * Wraps the storage and simluates\n * delays. Mostly used in tests.\n */\nexport function randomDelayStorage(input) {\n  /**\n   * Ensure writes to a delay storage\n   * are still correctly run in order.\n   */\n  var randomDelayStorageWriteQueue = PROMISE_RESOLVE_TRUE;\n  var retStorage = {\n    name: 'random-delay-' + input.storage.name,\n    rxdbVersion: RXDB_VERSION,\n    async createStorageInstance(params) {\n      await promiseWait(input.delayTimeBefore());\n      var storageInstance = await input.storage.createStorageInstance(params);\n      await promiseWait(input.delayTimeAfter());\n      return {\n        databaseName: storageInstance.databaseName,\n        internals: storageInstance.internals,\n        options: storageInstance.options,\n        schema: storageInstance.schema,\n        collectionName: storageInstance.collectionName,\n        bulkWrite(a, b) {\n          randomDelayStorageWriteQueue = randomDelayStorageWriteQueue.then(async () => {\n            await promiseWait(input.delayTimeBefore());\n            var response = await storageInstance.bulkWrite(a, b);\n            await promiseWait(input.delayTimeAfter());\n            return response;\n          });\n          var ret = randomDelayStorageWriteQueue;\n          return ret;\n        },\n        async findDocumentsById(a, b) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.findDocumentsById(a, b);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async query(a) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.query(a);\n          return ret;\n        },\n        async count(a) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.count(a);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async getAttachmentData(a, b, c) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.getAttachmentData(a, b, c);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : async (a, b) => {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await ensureNotFalsy(storageInstance.getChangedDocumentsSince)(a, b);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        changeStream() {\n          return storageInstance.changeStream();\n        },\n        conflictResultionTasks() {\n          return storageInstance.conflictResultionTasks();\n        },\n        resolveConflictResultionTask(a) {\n          return storageInstance.resolveConflictResultionTask(a);\n        },\n        async cleanup(a) {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.cleanup(a);\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async close() {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.close();\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        },\n        async remove() {\n          await promiseWait(input.delayTimeBefore());\n          var ret = await storageInstance.remove();\n          await promiseWait(input.delayTimeAfter());\n          return ret;\n        }\n      };\n    }\n  };\n  return retStorage;\n}\n"],
  "mappings": "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",
  "names": []
}
