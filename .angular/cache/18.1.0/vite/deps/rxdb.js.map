{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/dist/esm/rx-schema.js", "../../../../../node_modules/rxdb/dist/esm/incremental-write.js", "../../../../../node_modules/rxdb/dist/esm/rx-document.js", "../../../../../node_modules/rxdb/dist/esm/rx-database-internal-store.js", "../../../../../node_modules/rxdb/dist/esm/rx-collection-helper.js", "../../../../../node_modules/rxdb/dist/esm/change-event-buffer.js", "../../../../../node_modules/rxdb/dist/esm/rx-document-prototype-merge.js", "../../../../../node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js", "../../../../../node_modules/rxdb/dist/esm/replication-protocol/helper.js", "../../../../../node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js", "../../../../../node_modules/rxdb/dist/esm/replication-protocol/downstream.js", "../../../../../node_modules/rxdb/dist/esm/replication-protocol/conflicts.js", "../../../../../node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js", "../../../../../node_modules/rxdb/dist/esm/plugins/attachments/index.js", "../../../../../node_modules/rxdb/dist/esm/replication-protocol/upstream.js", "../../../../../node_modules/rxdb/dist/esm/replication-protocol/index.js", "../../../../../node_modules/rxdb/dist/esm/rx-collection.js", "../../../../../node_modules/custom-idle-queue/dist/es/index.js", "../../../../../node_modules/rxdb/dist/esm/rx-database.js", "../../../../../node_modules/rxdb/dist/esm/plugin.js", "../../../../../node_modules/rxdb/dist/esm/custom-index.js"],
  "sourcesContent": ["import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { overwriteGetterForCaching, isMaybeReadonlyArray, deepEqual } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getFinalFields, getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath, normalizeRxJsonSchema } from \"./rx-schema-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nexport var RxSchema = /*#__PURE__*/function () {\n  function RxSchema(jsonSchema, hashFunction) {\n    this.jsonSchema = jsonSchema;\n    this.hashFunction = hashFunction;\n    this.indexes = getIndexes(this.jsonSchema);\n\n    // primary is always required\n    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);\n    this.finalFields = getFinalFields(this.jsonSchema);\n  }\n  var _proto = RxSchema.prototype;\n  /**\n   * checks if a given change on a document is allowed\n   * Ensures that:\n   * - final fields are not modified\n   * @throws {Error} if not valid\n   */\n  _proto.validateChange = function validateChange(dataBefore, dataAfter) {\n    this.finalFields.forEach(fieldName => {\n      if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {\n        throw newRxError('DOC9', {\n          dataBefore,\n          dataAfter,\n          fieldName,\n          schema: this.jsonSchema\n        });\n      }\n    });\n  }\n\n  /**\n   * creates the schema-based document-prototype,\n   * see RxCollection.getDocumentPrototype()\n   */;\n  _proto.getDocumentPrototype = function getDocumentPrototype() {\n    var proto = {};\n\n    /**\n     * On the top level, we know all keys\n     * and therefore do not have to create a new Proxy object\n     * for each document. Instead we define the getter in the prototype once.\n     */\n    var pathProperties = getSchemaByObjectPath(this.jsonSchema, '');\n    Object.keys(pathProperties).forEach(key => {\n      var fullPath = key;\n\n      // getter - value\n      proto.__defineGetter__(key, function () {\n        if (!this.get || typeof this.get !== 'function') {\n          /**\n           * When an object gets added to the state of a vuejs-component,\n           * it happens that this getter is called with another scope.\n           * To prevent errors, we have to return undefined in this case\n           */\n          return undefined;\n        }\n        var ret = this.get(fullPath);\n        return ret;\n      });\n      // getter - observable$\n      Object.defineProperty(proto, key + '$', {\n        get: function () {\n          return this.get$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - reactivity$$\n      Object.defineProperty(proto, key + '$$', {\n        get: function () {\n          return this.get$$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - populate_\n      Object.defineProperty(proto, key + '_', {\n        get: function () {\n          return this.populate(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n    });\n    overwriteGetterForCaching(this, 'getDocumentPrototype', () => proto);\n    return proto;\n  };\n  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {\n    return getComposedPrimaryKeyOfDocumentData(this.jsonSchema, documentData);\n  };\n  return _createClass(RxSchema, [{\n    key: \"version\",\n    get: function () {\n      return this.jsonSchema.version;\n    }\n  }, {\n    key: \"defaultValues\",\n    get: function () {\n      var values = {};\n      Object.entries(this.jsonSchema.properties).filter(([, v]) => Object.prototype.hasOwnProperty.call(v, 'default')).forEach(([k, v]) => values[k] = v.default);\n      return overwriteGetterForCaching(this, 'defaultValues', values);\n    }\n\n    /**\n     * @overrides itself on the first call\n     *\n     * TODO this should be a pure function that\n     * caches the hash in a WeakMap.\n     */\n  }, {\n    key: \"hash\",\n    get: function () {\n      return overwriteGetterForCaching(this, 'hash', this.hashFunction(JSON.stringify(this.jsonSchema)));\n    }\n  }]);\n}();\nexport function getIndexes(jsonSchema) {\n  return (jsonSchema.indexes || []).map(index => isMaybeReadonlyArray(index) ? index : [index]);\n}\n\n/**\n * array with previous version-numbers\n */\nexport function getPreviousVersions(schema) {\n  var version = schema.version ? schema.version : 0;\n  var c = 0;\n  return new Array(version).fill(0).map(() => c++);\n}\nexport function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {\n  if (runPreCreateHooks) {\n    runPluginHooks('preCreateRxSchema', jsonSchema);\n  }\n  var useJsonSchema = fillWithDefaultSettings(jsonSchema);\n  useJsonSchema = normalizeRxJsonSchema(useJsonSchema);\n  overwritable.deepFreezeWhenDevMode(useJsonSchema);\n  var schema = new RxSchema(useJsonSchema, hashFunction);\n  runPluginHooks('createRxSchema', schema);\n  return schema;\n}\nexport function isRxSchema(obj) {\n  return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport function toTypedRxJsonSchema(schema) {\n  return schema;\n}\n", "import { isBulkWriteConflictError, rxStorageWriteErrorToRxError } from \"./rx-error.js\";\nimport { clone, ensureNotFalsy, getFromMapOrCreate, getFromMapOrThrow, getHeightOfRevision, stripMetaDataFromDocument } from \"./plugins/utils/index.js\";\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport var IncrementalWriteQueue = /*#__PURE__*/function () {\n  function IncrementalWriteQueue(storageInstance, primaryPath,\n  // can be used to run hooks etc.\n  preWrite, postWrite) {\n    this.queueByDocId = new Map();\n    this.isRunning = false;\n    this.storageInstance = storageInstance;\n    this.primaryPath = primaryPath;\n    this.preWrite = preWrite;\n    this.postWrite = postWrite;\n  }\n  var _proto = IncrementalWriteQueue.prototype;\n  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {\n    var docId = lastKnownDocumentState[this.primaryPath];\n    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n    var ret = new Promise((resolve, reject) => {\n      var item = {\n        lastKnownDocumentState,\n        modifier,\n        resolve,\n        reject\n      };\n      ensureNotFalsy(ar).push(item);\n      this.triggerRun();\n    });\n    return ret;\n  };\n  _proto.triggerRun = async function triggerRun() {\n    if (this.isRunning === true || this.queueByDocId.size === 0) {\n      // already running\n      return;\n    }\n    this.isRunning = true;\n    var writeRows = [];\n\n    /**\n     * 'take over' so that while the async functions runs,\n     * new incremental updates could be added from the outside.\n     */\n    var itemsById = this.queueByDocId;\n    this.queueByDocId = new Map();\n    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {\n      var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));\n      var newData = oldData;\n      for (var item of items) {\n        try {\n          newData = await item.modifier(\n          /**\n           * We have to clone() each time because the modifier\n           * might throw while it already changed some properties\n           * of the document.\n           */\n          clone(newData));\n        } catch (err) {\n          item.reject(err);\n          item.reject = () => {};\n          item.resolve = () => {};\n        }\n      }\n      try {\n        await this.preWrite(newData, oldData);\n      } catch (err) {\n        /**\n         * If the before-hooks fail,\n         * we reject all of the writes because it is\n         * not possible to determine which one is to blame.\n         */\n        items.forEach(item => item.reject(err));\n        return;\n      }\n      writeRows.push({\n        previous: oldData,\n        document: newData\n      });\n    }));\n    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {\n      error: [],\n      success: []\n    };\n\n    // process success\n    await Promise.all(writeResult.success.map(result => {\n      var docId = result[this.primaryPath];\n      this.postWrite(result);\n      var items = getFromMapOrThrow(itemsById, docId);\n      items.forEach(item => item.resolve(result));\n    }));\n\n    // process errors\n    writeResult.error.forEach(error => {\n      var docId = error.documentId;\n      var items = getFromMapOrThrow(itemsById, docId);\n      var isConflict = isBulkWriteConflictError(error);\n      if (isConflict) {\n        // had conflict -> retry afterwards\n        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n        /**\n         * Add the items back to this.queueByDocId\n         * by maintaining the original order.\n         */\n        items.reverse().forEach(item => {\n          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n          ensureNotFalsy(ar).unshift(item);\n        });\n      } else {\n        // other error -> must be thrown\n        var rxError = rxStorageWriteErrorToRxError(error);\n        items.forEach(item => item.reject(rxError));\n      }\n    });\n    this.isRunning = false;\n\n    /**\n     * Always trigger another run\n     * because in between there might be new items\n     * been added to the queue.\n     */\n    return this.triggerRun();\n  };\n  return IncrementalWriteQueue;\n}();\nexport function modifierFromPublicToInternal(publicModifier) {\n  var ret = async docData => {\n    var withoutMeta = stripMetaDataFromDocument(docData);\n    withoutMeta._deleted = docData._deleted;\n    var modified = await publicModifier(withoutMeta);\n    var reattachedMeta = Object.assign({}, modified, {\n      _meta: docData._meta,\n      _attachments: docData._attachments,\n      _rev: docData._rev,\n      _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted\n    });\n    if (typeof reattachedMeta._deleted === 'undefined') {\n      reattachedMeta._deleted = false;\n    }\n    return reattachedMeta;\n  };\n  return ret;\n}\nexport function findNewestOfDocumentStates(docs) {\n  var newest = docs[0];\n  var newestRevisionHeight = getHeightOfRevision(newest._rev);\n  docs.forEach(doc => {\n    var height = getHeightOfRevision(doc._rev);\n    if (height > newestRevisionHeight) {\n      newest = doc;\n      newestRevisionHeight = height;\n    }\n  });\n  return newest;\n}\n", "import { distinctUntilChanged, filter, map, shareReplay, startWith } from 'rxjs/operators';\nimport { clone, trimDots, pluginMissing, flatClone, PROMISE_RESOLVE_NULL, RXJS_SHARE_REPLAY_DEFAULTS, getProperty, getFromMapOrCreate } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { getDocumentDataOfRxChangeEvent } from \"./rx-change-event.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nimport { throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { modifierFromPublicToInternal } from \"./incremental-write.js\";\nexport var basePrototype = {\n  get primaryPath() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.collection.schema.primaryPath;\n  },\n  get primary() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data[_this.primaryPath];\n  },\n  get revision() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._rev;\n  },\n  get deleted$() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.$.pipe(map(d => d._data._deleted));\n  },\n  get deleted$$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.deleted$, _this.getLatest().deleted, _this.collection.database);\n  },\n  get deleted() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._deleted;\n  },\n  getLatest() {\n    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);\n    return this.collection._docCache.getCachedRxDocument(latestDocData);\n  },\n  /**\n   * returns the observable which emits the plain-data of this document\n   */\n  get $() {\n    var _this = this;\n    return _this.collection.$.pipe(filter(changeEvent => !changeEvent.isLocal), filter(changeEvent => changeEvent.documentId === this.primary), map(changeEvent => getDocumentDataOfRxChangeEvent(changeEvent)), startWith(_this.collection._docCache.getLatestDocumentData(this.primary)), distinctUntilChanged((prev, curr) => prev._rev === curr._rev), map(docData => this.collection._docCache.getCachedRxDocument(docData)), shareReplay(RXJS_SHARE_REPLAY_DEFAULTS));\n  },\n  get $$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.$, _this.getLatest()._data, _this.collection.database);\n  },\n  /**\n   * returns observable of the value of the given path\n   */\n  get$(path) {\n    if (overwritable.isDevMode()) {\n      if (path.includes('.item.')) {\n        throw newRxError('DOC1', {\n          path\n        });\n      }\n      if (path === this.primaryPath) {\n        throw newRxError('DOC2');\n      }\n\n      // final fields cannot be modified and so also not observed\n      if (this.collection.schema.finalFields.includes(path)) {\n        throw newRxError('DOC3', {\n          path\n        });\n      }\n      var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n      if (!schemaObj) {\n        throw newRxError('DOC4', {\n          path\n        });\n      }\n    }\n    return this.$.pipe(map(data => getProperty(data, path)), distinctUntilChanged());\n  },\n  get$$(path) {\n    var obs = this.get$(path);\n    var reactivity = this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(obs, this.getLatest().get(path), this.collection.database);\n  },\n  /**\n   * populate the given path\n   */\n  populate(path) {\n    var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n    var value = this.get(path);\n    if (!value) {\n      return PROMISE_RESOLVE_NULL;\n    }\n    if (!schemaObj) {\n      throw newRxError('DOC5', {\n        path\n      });\n    }\n    if (!schemaObj.ref) {\n      throw newRxError('DOC6', {\n        path,\n        schemaObj\n      });\n    }\n    var refCollection = this.collection.database.collections[schemaObj.ref];\n    if (!refCollection) {\n      throw newRxError('DOC7', {\n        ref: schemaObj.ref,\n        path,\n        schemaObj\n      });\n    }\n    if (schemaObj.type === 'array') {\n      return refCollection.findByIds(value).exec().then(res => {\n        var valuesIterator = res.values();\n        return Array.from(valuesIterator);\n      });\n    } else {\n      return refCollection.findOne(value).exec();\n    }\n  },\n  /**\n   * get data by objectPath\n   * @hotPath Performance here is really important,\n   * run some tests before changing anything.\n   */\n  get(objPath) {\n    return getFromMapOrCreate(this._propertyCache, objPath, () => {\n      var valueObj = getProperty(this._data, objPath);\n\n      // direct return if array or non-object\n      if (typeof valueObj !== 'object' || valueObj === null || Array.isArray(valueObj)) {\n        return overwritable.deepFreezeWhenDevMode(valueObj);\n      }\n      var _this = this;\n      var proxy = new Proxy(\n      /**\n       * In dev-mode, the _data is deep-frozen\n       * so we have to flat clone here so that\n       * the proxy can work.\n       */\n      flatClone(valueObj), {\n        get(target, property) {\n          if (typeof property !== 'string') {\n            return target[property];\n          }\n          var lastChar = property.charAt(property.length - 1);\n          if (property.endsWith('$$')) {\n            var key = property.slice(0, -2);\n            return _this.get$$(trimDots(objPath + '.' + key));\n          } else if (lastChar === '$') {\n            var _key = property.slice(0, -1);\n            return _this.get$(trimDots(objPath + '.' + _key));\n          } else if (lastChar === '_') {\n            var _key2 = property.slice(0, -1);\n            return _this.populate(trimDots(objPath + '.' + _key2));\n          } else {\n            return _this.get(trimDots(objPath + '.' + property));\n          }\n        }\n      });\n      return proxy;\n    });\n  },\n  toJSON(withMetaFields = false) {\n    if (!withMetaFields) {\n      var data = flatClone(this._data);\n      delete data._rev;\n      delete data._attachments;\n      delete data._deleted;\n      delete data._meta;\n      return overwritable.deepFreezeWhenDevMode(data);\n    } else {\n      return overwritable.deepFreezeWhenDevMode(this._data);\n    }\n  },\n  toMutableJSON(withMetaFields = false) {\n    return clone(this.toJSON(withMetaFields));\n  },\n  /**\n   * updates document\n   * @overwritten by plugin (optional)\n   * @param updateObj mongodb-like syntax\n   */\n  update(_updateObj) {\n    throw pluginMissing('update');\n  },\n  incrementalUpdate(_updateObj) {\n    throw pluginMissing('update');\n  },\n  updateCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  },\n  putAttachment() {\n    throw pluginMissing('attachments');\n  },\n  getAttachment() {\n    throw pluginMissing('attachments');\n  },\n  allAttachments() {\n    throw pluginMissing('attachments');\n  },\n  get allAttachments$() {\n    throw pluginMissing('attachments');\n  },\n  async modify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    var oldData = this._data;\n    var newData = await modifierFromPublicToInternal(mutationFunction)(oldData);\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * runs an incremental update over the document\n   * @param function that takes the document-data and returns a new data-object\n   */\n  incrementalModify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    return this.collection.incrementalWriteQueue.addWrite(this._data, modifierFromPublicToInternal(mutationFunction)).then(result => this.collection._docCache.getCachedRxDocument(result));\n  },\n  patch(patch) {\n    var oldData = this._data;\n    var newData = clone(oldData);\n    Object.entries(patch).forEach(([k, v]) => {\n      newData[k] = v;\n    });\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * patches the given properties\n   */\n  incrementalPatch(patch) {\n    return this.incrementalModify(docData => {\n      Object.entries(patch).forEach(([k, v]) => {\n        docData[k] = v;\n      });\n      return docData;\n    });\n  },\n  /**\n   * saves the new document-data\n   * and handles the events\n   */\n  async _saveData(newData, oldData) {\n    newData = flatClone(newData);\n\n    // deleted documents cannot be changed\n    if (this._data._deleted) {\n      throw newRxError('DOC11', {\n        id: this.primary,\n        document: this\n      });\n    }\n    await beforeDocumentUpdateWrite(this.collection, newData, oldData);\n    var writeResult = await this.collection.storageInstance.bulkWrite([{\n      previous: oldData,\n      document: newData\n    }], 'rx-document-save-data');\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);\n    await this.collection._runHooks('post', 'save', newData, this);\n    return this.collection._docCache.getCachedRxDocument(writeResult.success[0]);\n  },\n  /**\n   * Remove the document.\n   * Notice that there is no hard delete,\n   * instead deleted documents get flagged with _deleted=true.\n   */\n  remove() {\n    var collection = this.collection;\n    if (this.deleted) {\n      return Promise.reject(newRxError('DOC13', {\n        document: this,\n        id: this.primary\n      }));\n    }\n    var deletedData = flatClone(this._data);\n    var removedDocData;\n    return collection._runHooks('pre', 'remove', deletedData, this).then(async () => {\n      deletedData._deleted = true;\n      var writeResult = await collection.storageInstance.bulkWrite([{\n        previous: this._data,\n        document: deletedData\n      }], 'rx-document-remove');\n      var isError = writeResult.error[0];\n      throwIfIsStorageWriteError(collection, this.primary, deletedData, isError);\n      return writeResult.success[0];\n    }).then(removed => {\n      removedDocData = removed;\n      return this.collection._runHooks('post', 'remove', deletedData, this);\n    }).then(() => {\n      return this.collection._docCache.getCachedRxDocument(removedDocData);\n    });\n  },\n  incrementalRemove() {\n    return this.incrementalModify(async docData => {\n      await this.collection._runHooks('pre', 'remove', docData, this);\n      docData._deleted = true;\n      return docData;\n    }).then(async newDoc => {\n      await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);\n      return newDoc;\n    });\n  },\n  destroy() {\n    throw newRxError('DOC14');\n  }\n};\nexport function createRxDocumentConstructor(proto = basePrototype) {\n  var constructor = function RxDocumentConstructor(collection, docData) {\n    this.collection = collection;\n\n    // assume that this is always equal to the doc-data in the database\n    this._data = docData;\n    this._propertyCache = new Map();\n\n    /**\n     * because of the prototype-merge,\n     * we can not use the native instanceof operator\n     */\n    this.isInstanceOfRxDocument = true;\n  };\n  constructor.prototype = proto;\n  return constructor;\n}\nexport function createWithConstructor(constructor, collection, jsonData) {\n  var doc = new constructor(collection, jsonData);\n  runPluginHooks('createRxDocument', doc);\n  return doc;\n}\nexport function isRxDocument(obj) {\n  return typeof obj === 'object' && obj !== null && 'isInstanceOfRxDocument' in obj;\n}\nexport function beforeDocumentUpdateWrite(collection, newData, oldData) {\n  /**\n   * Meta values must always be merged\n   * instead of overwritten.\n   * This ensures that different plugins do not overwrite\n   * each others meta properties.\n   */\n  newData._meta = Object.assign({}, oldData._meta, newData._meta);\n\n  // ensure modifications are ok\n  if (overwritable.isDevMode()) {\n    collection.schema.validateChange(oldData, newData);\n  }\n  return collection._runHooks('pre', 'save', newData, oldData);\n}\n", "import { isBulkWriteConflictError, newRxError } from \"./rx-error.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData } from \"./rx-schema-helper.js\";\nimport { getSingleDocument, writeSingle } from \"./rx-storage-helper.js\";\nimport { clone, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, randomCouchString } from \"./plugins/utils/index.js\";\nimport { prepareQuery } from \"./rx-query.js\";\nexport var INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport var INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\nexport var INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport var INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\nexport var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({\n  version: 0,\n  title: INTERNAL_STORE_SCHEMA_TITLE,\n  primaryKey: {\n    key: 'id',\n    fields: ['context', 'key'],\n    separator: '|'\n  },\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 200\n    },\n    key: {\n      type: 'string'\n    },\n    context: {\n      type: 'string',\n      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, INTERNAL_CONTEXT_MIGRATION_STATUS, 'OTHER']\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  indexes: [],\n  required: ['key', 'context', 'data'],\n  additionalProperties: false,\n  /**\n   * If the sharding plugin is used,\n   * it must not shard on the internal RxStorageInstance\n   * because that one anyway has only a small amount of documents\n   * and also its creation is in the hot path of the initial page load,\n   * so we should spend less time creating multiple RxStorageInstances.\n   */\n  sharding: {\n    shards: 1,\n    mode: 'collection'\n  }\n});\nexport function getPrimaryKeyOfInternalDocument(key, context) {\n  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {\n    key,\n    context\n  });\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(storageInstance) {\n  var getAllQueryPrepared = prepareQuery(storageInstance.schema, {\n    selector: {\n      context: INTERNAL_CONTEXT_COLLECTION,\n      _deleted: {\n        $eq: false\n      }\n    },\n    sort: [{\n      id: 'asc'\n    }],\n    skip: 0\n  });\n  var queryResult = await storageInstance.query(getAllQueryPrepared);\n  var allDocs = queryResult.documents;\n  return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport var STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nexport var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);\nexport async function ensureStorageTokenDocumentExists(rxDatabase) {\n  /**\n   * To have less read-write cycles,\n   * we just try to insert a new document\n   * and only fetch the existing one if a conflict happened.\n   */\n  var storageToken = randomCouchString(10);\n  var passwordHash = rxDatabase.password ? await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;\n  var docData = {\n    id: STORAGE_TOKEN_DOCUMENT_ID,\n    context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n    key: STORAGE_TOKEN_DOCUMENT_KEY,\n    data: {\n      rxdbVersion: rxDatabase.rxdbVersion,\n      token: storageToken,\n      /**\n       * We add the instance token here\n       * to be able to detect if a given RxDatabase instance\n       * is the first instance that was ever created\n       * or if databases have existed earlier on that storage\n       * with the same database name.\n       */\n      instanceToken: rxDatabase.token,\n      passwordHash\n    },\n    _deleted: false,\n    _meta: getDefaultRxDocumentMeta(),\n    _rev: getDefaultRevision(),\n    _attachments: {}\n  };\n  var writeResult = await rxDatabase.internalStore.bulkWrite([{\n    document: docData\n  }], 'internal-add-storage-token');\n  if (writeResult.success[0]) {\n    return writeResult.success[0];\n  }\n\n  /**\n   * If we get a 409 error,\n   * it means another instance already inserted the storage token.\n   * So we get that token from the database and return that one.\n   */\n  var error = ensureNotFalsy(writeResult.error[0]);\n  if (error.isError && isBulkWriteConflictError(error)) {\n    var conflictError = error;\n    if (!isDatabaseStateVersionCompatibleWithDatabaseCode(conflictError.documentInDb.data.rxdbVersion, rxDatabase.rxdbVersion)) {\n      throw newRxError('DM5', {\n        args: {\n          database: rxDatabase.name,\n          databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\n          codeVersion: rxDatabase.rxdbVersion\n        }\n      });\n    }\n    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {\n      throw newRxError('DB1', {\n        passwordHash,\n        existingPasswordHash: conflictError.documentInDb.data.passwordHash\n      });\n    }\n    var storageTokenDocInDb = conflictError.documentInDb;\n    return ensureNotFalsy(storageTokenDocInDb);\n  }\n  throw error;\n}\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(databaseStateVersion, codeVersion) {\n  if (!databaseStateVersion) {\n    return false;\n  }\n  if (codeVersion.includes('beta') && codeVersion !== databaseStateVersion) {\n    return false;\n  }\n  var stateMajor = databaseStateVersion.split('.')[0];\n  var codeMajor = codeVersion.split('.')[0];\n  if (stateMajor !== codeMajor) {\n    return false;\n  }\n  return true;\n}\nexport async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if already in array\n    var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (alreadyThere) {\n      return;\n    }\n\n    // otherwise add to array and save\n    saveData.data.connectedStorages.push({\n      collectionName: storageCollectionName,\n      schema\n    });\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'add-connected-storage-to-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\nexport async function removeConnectedStorageFromCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if not there\n    var isThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (!isThere) {\n      return;\n    }\n\n    // otherwise remove from array and save\n    saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'remove-connected-storage-from-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nexport function _collectionNamePrimary(name, schema) {\n  return name + '-' + schema.version;\n}\n", "import { createRevision, flatClone, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"./plugins/utils/index.js\";\nimport { fillObjectWithDefaults, fillPrimaryKey } from \"./rx-schema-helper.js\";\nimport { runAsyncPluginHooks } from \"./hooks.js\";\nimport { getAllCollectionDocuments } from \"./rx-database-internal-store.js\";\nimport { flatCloneDocWithMeta } from \"./rx-storage-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { newRxError } from \"./rx-error.js\";\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nexport function fillObjectDataBeforeInsert(schema, data) {\n  data = flatClone(data);\n  data = fillObjectWithDefaults(schema, data);\n  data = fillPrimaryKey(schema.primaryPath, schema.jsonSchema, data);\n  data._meta = getDefaultRxDocumentMeta();\n  if (!Object.prototype.hasOwnProperty.call(data, '_deleted')) {\n    data._deleted = false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_attachments')) {\n    data._attachments = {};\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_rev')) {\n    data._rev = getDefaultRevision();\n  }\n  return data;\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nexport async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {\n  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;\n  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);\n  return storageInstance;\n}\n\n/**\n * Removes the main storage of the collection\n * and all connected storages like the ones from the replication meta etc.\n */\nexport async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, password,\n/**\n * If no hash function is provided,\n * we assume that the whole internal store is removed anyway\n * so we do not have to delete the meta documents.\n */\nhashFunction) {\n  var allCollectionMetaDocs = await getAllCollectionDocuments(databaseInternalStorage);\n  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter(metaDoc => metaDoc.data.name === collectionName);\n  var removeStorages = [];\n  relevantCollectionMetaDocs.forEach(metaDoc => {\n    removeStorages.push({\n      collectionName: metaDoc.data.name,\n      schema: metaDoc.data.schema,\n      isCollection: true\n    });\n    metaDoc.data.connectedStorages.forEach(row => removeStorages.push({\n      collectionName: row.collectionName,\n      isCollection: false,\n      schema: row.schema\n    }));\n  });\n\n  // ensure uniqueness\n  var alreadyAdded = new Set();\n  removeStorages = removeStorages.filter(row => {\n    var key = row.collectionName + '||' + row.schema.version;\n    if (alreadyAdded.has(key)) {\n      return false;\n    } else {\n      alreadyAdded.add(key);\n      return true;\n    }\n  });\n\n  // remove all the storages\n  await Promise.all(removeStorages.map(async row => {\n    var storageInstance = await storage.createStorageInstance({\n      collectionName: row.collectionName,\n      databaseInstanceToken,\n      databaseName,\n      multiInstance: false,\n      options: {},\n      schema: row.schema,\n      password,\n      devMode: overwritable.isDevMode()\n    });\n    await storageInstance.remove();\n    if (row.isCollection) {\n      await runAsyncPluginHooks('postRemoveRxCollection', {\n        storage,\n        databaseName: databaseName,\n        collectionName\n      });\n    }\n  }));\n\n  // remove the meta documents\n  if (hashFunction) {\n    var writeRows = relevantCollectionMetaDocs.map(doc => {\n      var writeDoc = flatCloneDocWithMeta(doc);\n      writeDoc._deleted = true;\n      writeDoc._meta.lwt = now();\n      writeDoc._rev = createRevision(databaseInstanceToken, doc);\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    await databaseInternalStorage.bulkWrite(writeRows, 'rx-database-remove-collection-all');\n  }\n}\nexport function ensureRxCollectionIsNotDestroyed(collection) {\n  if (collection.destroyed) {\n    throw newRxError('COL21', {\n      collection: collection.name,\n      version: collection.schema.version\n    });\n  }\n}\n", "/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\n\nimport { filter } from 'rxjs/operators';\nexport var ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n   */\n\n  function ChangeEventBuffer(collection) {\n    this.subs = [];\n    this.limit = 100;\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.collection = collection;\n    this.subs.push(this.collection.$.pipe(filter(cE => !cE.isLocal)).subscribe(cE => this._handleChangeEvent(cE)));\n  }\n  var _proto = ChangeEventBuffer.prototype;\n  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {\n    this.counter++;\n    this.buffer.push(changeEvent);\n    this.eventCounterMap.set(changeEvent, this.counter);\n    while (this.buffer.length > this.limit) {\n      this.buffer.shift();\n    }\n  }\n\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n   */;\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. If null, pointer out of bounds\n   */;\n  _proto.getFrom = function getFrom(pointer) {\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null)\n      // out of bounds\n      return null;\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) {\n        return ret;\n      } else {\n        ret.push(nextEvent);\n      }\n    }\n  };\n  _proto.runFrom = function runFrom(pointer, fn) {\n    var ret = this.getFrom(pointer);\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(cE => fn(cE));\n    }\n  }\n\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc\n   */;\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    return changeEvents.slice(0);\n    // TODO the old implementation was wrong\n    // because it did not correctly reassigned the previousData of the changeevents\n    // this should be added to the event-reduce library and not be done in RxDB\n    var docEventMap = {};\n    changeEvents.forEach(changeEvent => {\n      docEventMap[changeEvent.documentId] = changeEvent;\n    });\n    return Object.values(docEventMap);\n  };\n  _proto.destroy = function destroy() {\n    this.subs.forEach(sub => sub.unsubscribe());\n  };\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}\n", "/**\n * For the ORM capabilities,\n * we have to merge the document prototype\n * with the ORM functions and the data\n * We do this iterating over the properties and\n * adding them to a new object.\n * In the future we should do this by chaining the __proto__ objects\n */\n\nimport { createRxDocumentConstructor, basePrototype, createWithConstructor as createRxDocumentWithConstructor } from \"./rx-document.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getFromMapOrCreate } from \"./plugins/utils/index.js\";\nvar constructorForCollection = new WeakMap();\nexport function getDocumentPrototype(rxCollection) {\n  var schemaProto = rxCollection.schema.getDocumentPrototype();\n  var ormProto = getDocumentOrmPrototype(rxCollection);\n  var baseProto = basePrototype;\n  var proto = {};\n  [schemaProto, ormProto, baseProto].forEach(obj => {\n    var props = Object.getOwnPropertyNames(obj);\n    props.forEach(key => {\n      var desc = Object.getOwnPropertyDescriptor(obj, key);\n      /**\n       * When enumerable is true, it will show on console dir(instance)\n       * To not pollute the output, only getters and methods are enumerable\n       */\n      var enumerable = true;\n      if (key.startsWith('_') || key.endsWith('_') || key.startsWith('$') || key.endsWith('$')) enumerable = false;\n      if (typeof desc.value === 'function') {\n        // when getting a function, we automatically do a .bind(this)\n        Object.defineProperty(proto, key, {\n          get() {\n            return desc.value.bind(this);\n          },\n          enumerable,\n          configurable: false\n        });\n      } else {\n        desc.enumerable = enumerable;\n        desc.configurable = false;\n        if (desc.writable) desc.writable = false;\n        Object.defineProperty(proto, key, desc);\n      }\n    });\n  });\n  return proto;\n}\nexport function getRxDocumentConstructor(rxCollection) {\n  return getFromMapOrCreate(constructorForCollection, rxCollection, () => createRxDocumentConstructor(getDocumentPrototype(rxCollection)));\n}\n\n/**\n * Create a RxDocument-instance from the jsonData\n * and the prototype merge.\n * You should never call this method directly,\n * instead you should get the document from collection._docCache.getCachedRxDocument().\n */\nexport function createNewRxDocument(rxCollection, documentConstructor, docData) {\n  var doc = createRxDocumentWithConstructor(documentConstructor, rxCollection, overwritable.deepFreezeWhenDevMode(docData));\n  rxCollection._runHooksSync('post', 'create', docData, doc);\n  runPluginHooks('postCreateRxDocument', doc);\n  return doc;\n}\n\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n */\nexport function getDocumentOrmPrototype(rxCollection) {\n  var proto = {};\n  Object.entries(rxCollection.methods).forEach(([k, v]) => {\n    proto[k] = v;\n  });\n  return proto;\n}\n", "import { getComposedPrimaryKeyOfDocumentData } from \"../rx-schema-helper.js\";\nimport { stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { createRevision, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"../plugins/utils/index.js\";\nexport async function getLastCheckpointDoc(state, direction) {\n  var checkpointDocId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n    isCheckpoint: '1',\n    itemId: direction\n  });\n  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);\n  var checkpointDoc = checkpointResult[0];\n  state.lastCheckpointDoc[direction] = checkpointDoc;\n  if (checkpointDoc) {\n    return checkpointDoc.checkpointData;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nexport async function setCheckpoint(state, direction, checkpoint) {\n  state.checkpointQueue = state.checkpointQueue.then(async () => {\n    var previousCheckpointDoc = state.lastCheckpointDoc[direction];\n    if (checkpoint &&\n    /**\n     * If the replication is already canceled,\n     * we do not write a checkpoint\n     * because that could mean we write a checkpoint\n     * for data that has been fetched from the master\n     * but not been written to the child.\n     */\n    !state.events.canceled.getValue() && (\n    /**\n     * Only write checkpoint if it is different from before\n     * to have less writes to the storage.\n     */\n\n    !previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint))) {\n      var newDoc = {\n        id: '',\n        isCheckpoint: '1',\n        itemId: direction,\n        _deleted: false,\n        _attachments: {},\n        checkpointData: checkpoint,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision()\n      };\n      newDoc.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newDoc);\n      while (!state.events.canceled.getValue()) {\n        /**\n         * Instead of just storing the new checkpoint,\n         * we have to stack up the checkpoint with the previous one.\n         * This is required for plugins like the sharding RxStorage\n         * where the changeStream events only contain a Partial of the\n         * checkpoint.\n         */\n        if (previousCheckpointDoc) {\n          newDoc.checkpointData = stackCheckpoints([previousCheckpointDoc.checkpointData, newDoc.checkpointData]);\n        }\n        newDoc._meta.lwt = now();\n        newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n        if (state.events.canceled.getValue()) {\n          return;\n        }\n        var result = await state.input.metaInstance.bulkWrite([{\n          previous: previousCheckpointDoc,\n          document: newDoc\n        }], 'replication-set-checkpoint');\n        var sucessDoc = result.success[0];\n        if (sucessDoc) {\n          state.lastCheckpointDoc[direction] = sucessDoc;\n          return;\n        } else {\n          var error = result.error[0];\n          if (error.status !== 409) {\n            throw error;\n          } else {\n            previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n            newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n          }\n        }\n      }\n    }\n  });\n  await state.checkpointQueue;\n}\nexport async function getCheckpointKey(input) {\n  var hash = await input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join('||'));\n  return 'rx_storage_replication_' + hash;\n}\n", "import { clone, createRevision, flatClone, getDefaultRevision, now } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport function docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, docState, previous) {\n  var docData = Object.assign({}, docState, {\n    _attachments: hasAttachments && docState._attachments ? docState._attachments : {},\n    _meta: keepMeta ? docState._meta : Object.assign({}, previous ? previous._meta : {}, {\n      lwt: now()\n    }),\n    _rev: keepMeta ? docState._rev : getDefaultRevision()\n  });\n  if (!docData._rev) {\n    docData._rev = createRevision(databaseInstanceToken, previous);\n  }\n  return docData;\n}\nexport function writeDocToDocState(writeDoc, keepAttachments, keepMeta) {\n  var ret = flatClone(writeDoc);\n  if (!keepAttachments) {\n    delete ret._attachments;\n  }\n  if (!keepMeta) {\n    delete ret._meta;\n    delete ret._rev;\n  }\n  return ret;\n}\nexport function stripAttachmentsDataFromMetaWriteRows(state, rows) {\n  if (!state.hasAttachments) {\n    return rows;\n  }\n  return rows.map(row => {\n    var document = clone(row.document);\n    document.docData = stripAttachmentsDataFromDocument(document.docData);\n    return {\n      document,\n      previous: row.previous\n    };\n  });\n}\nexport function getUnderlyingPersistentStorage(instance) {\n  while (true) {\n    if (instance.underlyingPersistentStorage) {\n      instance = instance.underlyingPersistentStorage;\n    } else {\n      return instance;\n    }\n  }\n}\n", "import { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getLengthOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { flatCloneDocWithMeta } from \"../rx-storage-helper.js\";\nimport { getDefaultRevision, createRevision, now } from \"../plugins/utils/index.js\";\nexport var META_INSTANCE_SCHEMA_TITLE = 'RxReplicationProtocolMetaData';\nexport function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {\n  var parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\n  var baseSchema = {\n    title: META_INSTANCE_SCHEMA_TITLE,\n    primaryKey: {\n      key: 'id',\n      fields: ['itemId', 'isCheckpoint'],\n      separator: '|'\n    },\n    type: 'object',\n    version: replicatedDocumentsSchema.version,\n    additionalProperties: false,\n    properties: {\n      id: {\n        type: 'string',\n        minLength: 1,\n        // add +1 for the '|' and +1 for the 'isCheckpoint' flag\n        maxLength: parentPrimaryKeyLength + 2\n      },\n      isCheckpoint: {\n        type: 'string',\n        enum: ['0', '1'],\n        minLength: 1,\n        maxLength: 1\n      },\n      itemId: {\n        type: 'string',\n        /**\n         * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it\n         * because checkpoints use the itemId field for that.\n         */\n        maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4\n      },\n      checkpointData: {\n        type: 'object',\n        additionalProperties: true\n      },\n      docData: {\n        type: 'object',\n        properties: replicatedDocumentsSchema.properties\n      },\n      isResolvedConflict: {\n        type: 'string'\n      }\n    },\n    keyCompression: replicatedDocumentsSchema.keyCompression,\n    required: ['id', 'isCheckpoint', 'itemId']\n  };\n  if (encrypted) {\n    baseSchema.encrypted = ['docData'];\n  }\n  var metaInstanceSchema = fillWithDefaultSettings(baseSchema);\n  return metaInstanceSchema;\n}\n\n/**\n * Returns the document states of what the fork instance\n * assumes to be the latest state on the master instance.\n */\nexport function getAssumedMasterState(state, docIds) {\n  return state.input.metaInstance.findDocumentsById(docIds.map(docId => {\n    var useId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n      itemId: docId,\n      isCheckpoint: '0'\n    });\n    return useId;\n  }), true).then(metaDocs => {\n    var ret = {};\n    Object.values(metaDocs).forEach(metaDoc => {\n      ret[metaDoc.itemId] = {\n        docData: metaDoc.docData,\n        metaDocument: metaDoc\n      };\n    });\n    return ret;\n  });\n}\nexport async function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {\n  var docId = newMasterDocState[state.primaryPath];\n  var newMeta = previous ? flatCloneDocWithMeta(previous) : {\n    id: '',\n    isCheckpoint: '0',\n    itemId: docId,\n    docData: newMasterDocState,\n    _attachments: {},\n    _deleted: false,\n    _rev: getDefaultRevision(),\n    _meta: {\n      lwt: 0\n    }\n  };\n  newMeta.docData = newMasterDocState;\n\n  /**\n   * Sending isResolvedConflict with the value undefined\n   * will throw a schema validation error because it must be either\n   * not set or have a string.\n   */\n  if (isResolvedConflict) {\n    newMeta.isResolvedConflict = isResolvedConflict;\n  }\n  newMeta._meta.lwt = now();\n  newMeta.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newMeta);\n  newMeta._rev = createRevision(await state.checkpointKey, previous);\n  var ret = {\n    previous,\n    document: newMeta\n  };\n  return ret;\n}\n", "import { firstValueFrom, filter, mergeMap } from 'rxjs';\nimport { newRxError } from \"../rx-error.js\";\nimport { stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, createRevision, ensureNotFalsy, flatClone, getDefaultRevision, getHeightOfRevision, now, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport async function startReplicationDownstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'down');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'down', state.input.initialCheckpoint.downstream);\n    }\n  }\n  var identifierHash = await state.input.hashFunction(state.input.identifier);\n  var replicationHandler = state.input.replicationHandler;\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var openTasks = [];\n  function addNewTask(task) {\n    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n    var taskWithTime = {\n      time: timer++,\n      task\n    };\n    openTasks.push(taskWithTime);\n    state.streamQueue.down = state.streamQueue.down.then(() => {\n      var useTasks = [];\n      while (openTasks.length > 0) {\n        state.events.active.down.next(true);\n        var innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n        /**\n         * If the task came in before the last time we started the pull\n         * from the master, then we can drop the task.\n         */\n        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n          continue;\n        }\n        if (innerTaskWithTime.task === 'RESYNC') {\n          if (useTasks.length === 0) {\n            useTasks.push(innerTaskWithTime.task);\n            break;\n          } else {\n            break;\n          }\n        }\n        useTasks.push(innerTaskWithTime.task);\n      }\n      if (useTasks.length === 0) {\n        return;\n      }\n      if (useTasks[0] === 'RESYNC') {\n        return downstreamResyncOnce();\n      } else {\n        return downstreamProcessChanges(useTasks);\n      }\n    }).then(() => {\n      state.events.active.down.next(false);\n      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {\n        state.firstSyncDone.down.next(true);\n      }\n    });\n  }\n  addNewTask('RESYNC');\n\n  /**\n   * If a write on the master happens, we have to trigger the downstream.\n   * Only do this if not canceled yet, otherwise firstValueFrom errors\n   * when running on a completed observable.\n   */\n  if (!state.events.canceled.getValue()) {\n    var sub = replicationHandler.masterChangeStream$.pipe(mergeMap(async ev => {\n      /**\n       * While a push is running, we have to delay all incoming\n       * events from the server to not mix up the replication state.\n       */\n      await firstValueFrom(state.events.active.up.pipe(filter(s => !s)));\n      return ev;\n    })).subscribe(task => {\n      state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n      addNewTask(task);\n    });\n    firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n  }\n\n  /**\n   * For faster performance, we directly start each write\n   * and then await all writes at the end.\n   */\n  var lastTimeMasterChangesRequested = -1;\n  async function downstreamResyncOnce() {\n    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = [];\n    while (!state.events.canceled.getValue()) {\n      lastTimeMasterChangesRequested = timer++;\n      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);\n      if (downResult.documents.length === 0) {\n        break;\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));\n\n      /**\n       * By definition we stop pull when the pulled documents\n       * do not fill up the pullBatchSize because we\n       * can assume that the remote has no more documents.\n       */\n      if (downResult.documents.length < state.input.pullBatchSize) {\n        break;\n      }\n    }\n    await Promise.all(promises);\n  }\n  function downstreamProcessChanges(tasks) {\n    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n    var docsOfAllTasks = [];\n    var lastCheckpoint = null;\n    tasks.forEach(task => {\n      if (task === 'RESYNC') {\n        throw new Error('SNH');\n      }\n      appendToArray(docsOfAllTasks, task.documents);\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n    });\n    return persistFromMaster(docsOfAllTasks, ensureNotFalsy(lastCheckpoint));\n  }\n\n  /**\n   * It can happen that the calls to masterChangesSince() or the changeStream()\n   * are way faster then how fast the documents can be persisted.\n   * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n   * and process them together if possible.\n   * This often bundles up single writes and improves performance\n   * by processing the documents in bulks.\n   */\n  var persistenceQueue = PROMISE_RESOLVE_VOID;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  function persistFromMaster(docs, checkpoint) {\n    var primaryPath = state.primaryPath;\n    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n\n    /**\n     * Run in the queue\n     * with all open documents from nonPersistedFromMaster.\n     */\n    persistenceQueue = persistenceQueue.then(() => {\n      var downDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(downDocsById);\n      if (state.events.canceled.getValue() || docIds.length === 0) {\n        return PROMISE_RESOLVE_VOID;\n      }\n      var writeRowsToFork = [];\n      var writeRowsToForkById = {};\n      var writeRowsToMeta = {};\n      var useMetaWriteRows = [];\n      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), getAssumedMasterState(state, docIds)]).then(([currentForkStateList, assumedMasterState]) => {\n        var currentForkState = new Map();\n        currentForkStateList.forEach(doc => currentForkState.set(doc[primaryPath], doc));\n        return Promise.all(docIds.map(async docId => {\n          var forkStateFullDoc = currentForkState.get(docId);\n          var forkStateDocData = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false) : undefined;\n          var masterState = downDocsById[docId];\n          var assumedMaster = assumedMasterState[docId];\n          if (assumedMaster && forkStateFullDoc && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {\n            /**\n             * The current fork state represents a resolved conflict\n             * that first must be send to the master in the upstream.\n             * All conflicts are resolved by the upstream.\n             */\n            // return PROMISE_RESOLVE_VOID;\n            await state.streamQueue.up;\n          }\n          var isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ? false : await state.input.conflictHandler({\n            realMasterState: assumedMaster.docData,\n            newDocumentState: forkStateDocData\n          }, 'downstream-check-if-equal-0').then(r => r.isEqual);\n          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc && forkStateFullDoc._meta[state.input.identifier] && getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]) {\n            isAssumedMasterEqualToForkState = true;\n          }\n          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {\n            /**\n             * We have a non-upstream-replicated\n             * local write to the fork.\n             * This means we ignore the downstream of this document\n             * because anyway the upstream will first resolve the conflict.\n             */\n            return PROMISE_RESOLVE_VOID;\n          }\n          var areStatesExactlyEqual = !forkStateDocData ? false : await state.input.conflictHandler({\n            realMasterState: masterState,\n            newDocumentState: forkStateDocData\n          }, 'downstream-check-if-equal-1').then(r => r.isEqual);\n          if (forkStateDocData && areStatesExactlyEqual) {\n            /**\n             * Document states are exactly equal.\n             * This can happen when the replication is shut down\n             * unexpected like when the user goes offline.\n             *\n             * Only when the assumedMaster is different from the forkState,\n             * we have to patch the document in the meta instance.\n             */\n            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {\n              useMetaWriteRows.push(await getMetaWriteRow(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : undefined));\n            }\n            return PROMISE_RESOLVE_VOID;\n          }\n\n          /**\n           * All other master states need to be written to the forkInstance\n           * and metaInstance.\n           */\n          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {\n            _meta: flatClone(forkStateFullDoc._meta),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},\n            _rev: getDefaultRevision()\n          } : {\n            _meta: {\n              lwt: now()\n            },\n            _rev: getDefaultRevision(),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}\n          });\n          /**\n           * If the remote works with revisions,\n           * we store the height of the next fork-state revision\n           * inside of the documents meta data.\n           * By doing so we can filter it out in the upstream\n           * and detect the document as being equal to master or not.\n           * This is used for example in the CouchDB replication plugin.\n           */\n          if (masterState._rev) {\n            var nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;\n            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n            if (state.input.keepMeta) {\n              newForkState._rev = masterState._rev;\n            }\n          }\n          if (state.input.keepMeta && masterState._meta) {\n            newForkState._meta = masterState._meta;\n          }\n          var forkWriteRow = {\n            previous: forkStateFullDoc,\n            document: newForkState\n          };\n          forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(identifierHash, forkWriteRow.previous);\n          writeRowsToFork.push(forkWriteRow);\n          writeRowsToForkById[docId] = forkWriteRow;\n          writeRowsToMeta[docId] = await getMetaWriteRow(state, masterState, assumedMaster ? assumedMaster.metaDocument : undefined);\n        }));\n      }).then(async () => {\n        if (writeRowsToFork.length > 0) {\n          return state.input.forkInstance.bulkWrite(writeRowsToFork, await state.downstreamBulkWriteFlag).then(forkWriteResult => {\n            forkWriteResult.success.forEach(doc => {\n              var docId = doc[primaryPath];\n              state.events.processed.down.next(writeRowsToForkById[docId]);\n              useMetaWriteRows.push(writeRowsToMeta[docId]);\n            });\n            forkWriteResult.error.forEach(error => {\n              /**\n               * We do not have to care about downstream conflict errors here\n               * because on conflict, it will be solved locally and result in another write.\n               */\n              if (error.status === 409) {\n                return;\n              }\n              // other non-conflict errors must be handled\n              state.events.error.next(newRxError('RC_PULL', {\n                writeError: error\n              }));\n            });\n          });\n        }\n      }).then(() => {\n        if (useMetaWriteRows.length > 0) {\n          return state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows), 'replication-down-write-meta').then(metaWriteResult => {\n            metaWriteResult.error.forEach(writeError => {\n              state.events.error.next(newRxError('RC_PULL', {\n                id: writeError.documentId,\n                writeError\n              }));\n            });\n          });\n        }\n      }).then(() => {\n        /**\n         * For better performance we do not await checkpoint writes,\n         * but to ensure order on parallel checkpoint writes,\n         * we have to use a queue.\n         */\n        setCheckpoint(state, 'down', useCheckpoint);\n      });\n    }).catch(unhandledError => state.events.error.next(unhandledError));\n    return persistenceQueue;\n  }\n}\n", "import { getDefaultRevision, createRevision, now, flatClone, deepEqual } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport var defaultConflictHandler = function (i, _context) {\n  var newDocumentState = stripAttachmentsDataFromDocument(i.newDocumentState);\n  var realMasterState = stripAttachmentsDataFromDocument(i.realMasterState);\n\n  /**\n   * If the documents are deep equal,\n   * we have no conflict.\n   * On your custom conflict handler you might only\n   * check some properties, like the updatedAt time,\n   * for better performance, because deepEqual is expensive.\n   */\n  if (deepEqual(newDocumentState, realMasterState)) {\n    return Promise.resolve({\n      isEqual: true\n    });\n  }\n\n  /**\n   * The default conflict handler will always\n   * drop the fork state and use the master state instead.\n   */\n  return Promise.resolve({\n    isEqual: false,\n    documentData: i.realMasterState\n  });\n};\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError(state, input, forkState) {\n  var conflictHandler = state.input.conflictHandler;\n  var conflictHandlerOutput = await conflictHandler(input, 'replication-resolve-conflict');\n  if (conflictHandlerOutput.isEqual) {\n    /**\n     * Documents are equal,\n     * so this is not a conflict -> do nothing.\n     */\n    return undefined;\n  } else {\n    /**\n     * We have a resolved conflict,\n     * use the resolved document data.\n     */\n    var resolvedDoc = Object.assign({}, conflictHandlerOutput.documentData, {\n      /**\n       * Because the resolved conflict is written to the fork,\n       * we have to keep/update the forks _meta data, not the masters.\n       */\n      _meta: flatClone(forkState._meta),\n      _rev: getDefaultRevision(),\n      _attachments: flatClone(forkState._attachments)\n    });\n    resolvedDoc._meta.lwt = now();\n    resolvedDoc._rev = createRevision(await state.checkpointKey, forkState);\n    return {\n      resolvedDoc,\n      output: conflictHandlerOutput\n    };\n  }\n}\n", "import { newRxError } from \"../../rx-error.js\";\nimport { ensureNotFalsy } from \"../utils/index.js\";\nexport function ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonSchema;\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\nexport function assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(([funName, fun]) => {\n    Object.defineProperty(attachment, funName, {\n      get: () => fun.bind(attachment)\n    });\n  });\n}\n\n/**\n * Fill up the missing attachment.data of the newDocument\n * so that the new document can be send to somewhere else\n * which could then receive all required attachments data\n * that it did not have before.\n */\nexport async function fillWriteDataForAttachmentsChange(primaryPath, storageInstance, newDocument, originalDocument) {\n  if (!newDocument._attachments || originalDocument && !originalDocument._attachments) {\n    throw new Error('_attachments missing');\n  }\n  var docId = newDocument[primaryPath];\n  var originalAttachmentsIds = new Set(originalDocument && originalDocument._attachments ? Object.keys(originalDocument._attachments) : []);\n  await Promise.all(Object.entries(newDocument._attachments).map(async ([key, value]) => {\n    if ((!originalAttachmentsIds.has(key) || originalDocument && ensureNotFalsy(originalDocument._attachments)[key].digest !== value.digest) && !value.data) {\n      var attachmentDataString = await storageInstance.getAttachmentData(docId, key, value.digest);\n      value.data = attachmentDataString;\n    }\n  }));\n  return newDocument;\n}\n", "import { map } from 'rxjs';\nimport { blobToBase64String, blobToString, createBlobFromBase64, flatClone, getBlobSize, PROMISE_RESOLVE_VOID } from \"../../plugins/utils/index.js\";\nimport { assignMethodsToAttachment, ensureSchemaSupportsAttachments } from \"./attachments-utils.js\";\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport var RxAttachment = /*#__PURE__*/function () {\n  function RxAttachment({\n    doc,\n    id,\n    type,\n    length,\n    digest\n  }) {\n    this.doc = doc;\n    this.id = id;\n    this.type = type;\n    this.length = length;\n    this.digest = digest;\n    assignMethodsToAttachment(this);\n  }\n  var _proto = RxAttachment.prototype;\n  _proto.remove = function remove() {\n    return this.doc.collection.incrementalWriteQueue.addWrite(this.doc._data, docWriteData => {\n      delete docWriteData._attachments[this.id];\n      return docWriteData;\n    }).then(() => {});\n  }\n\n  /**\n   * returns the data for the attachment\n   */;\n  _proto.getData = async function getData() {\n    var plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(this.doc.primary, this.id, this.digest);\n    var ret = await createBlobFromBase64(plainDataBase64, this.type);\n    return ret;\n  };\n  _proto.getStringData = async function getStringData() {\n    var data = await this.getData();\n    var asString = await blobToString(data);\n    return asString;\n  };\n  return RxAttachment;\n}();\nexport function fromStorageInstanceResult(id, attachmentData, rxDocument) {\n  return new RxAttachment({\n    doc: rxDocument,\n    id,\n    type: attachmentData.type,\n    length: attachmentData.length,\n    digest: attachmentData.digest\n  });\n}\nexport async function putAttachment(attachmentData) {\n  ensureSchemaSupportsAttachments(this);\n  var dataSize = getBlobSize(attachmentData.data);\n  var dataString = await blobToBase64String(attachmentData.data);\n  var digest = await this.collection.database.hashFunction(dataString);\n  var id = attachmentData.id;\n  var type = attachmentData.type;\n  var data = dataString;\n  return this.collection.incrementalWriteQueue.addWrite(this._data, docWriteData => {\n    docWriteData = flatClone(docWriteData);\n    docWriteData._attachments = flatClone(docWriteData._attachments);\n    docWriteData._attachments[id] = {\n      length: dataSize,\n      type,\n      data,\n      digest\n    };\n    return docWriteData;\n  }).then(writeResult => {\n    var newDocument = this.collection._docCache.getCachedRxDocument(writeResult);\n    var attachmentDataOfId = writeResult._attachments[id];\n    var attachment = fromStorageInstanceResult(id, attachmentDataOfId, newDocument);\n    return attachment;\n  });\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(id) {\n  ensureSchemaSupportsAttachments(this);\n  var docData = this._data;\n  if (!docData._attachments || !docData._attachments[id]) return null;\n  var attachmentData = docData._attachments[id];\n  var attachment = fromStorageInstanceResult(id, attachmentData, this);\n  return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments() {\n  ensureSchemaSupportsAttachments(this);\n  var docData = this._data;\n\n  // if there are no attachments, the field is missing\n  if (!docData._attachments) {\n    return [];\n  }\n  return Object.keys(docData._attachments).map(id => {\n    return fromStorageInstanceResult(id, docData._attachments[id], this);\n  });\n}\nexport async function preMigrateDocument(data) {\n  var attachments = data.docData._attachments;\n  if (attachments) {\n    var newAttachments = {};\n    await Promise.all(Object.keys(attachments).map(async attachmentId => {\n      var attachment = attachments[attachmentId];\n      var docPrimary = data.docData[data.oldCollection.schema.primaryPath];\n      var rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId, attachment.digest);\n      var digest = await data.oldCollection.database.hashFunction(rawAttachmentData);\n      newAttachments[attachmentId] = {\n        length: attachment.length,\n        type: attachment.type,\n        data: rawAttachmentData,\n        digest\n      };\n    }));\n\n    /**\n     * Hooks mutate the input\n     * instead of returning stuff\n     */\n    data.docData._attachments = newAttachments;\n  }\n}\nexport function postMigrateDocument(_action) {\n  /**\n   * No longer needed because\n   * we store the attachments data buffers directly in the document.\n   */\n  return PROMISE_RESOLVE_VOID;\n}\nexport var RxDBAttachmentsPlugin = {\n  name: 'attachments',\n  rxdb: true,\n  prototypes: {\n    RxDocument: proto => {\n      proto.putAttachment = putAttachment;\n      proto.getAttachment = getAttachment;\n      proto.allAttachments = allAttachments;\n      Object.defineProperty(proto, 'allAttachments$', {\n        get: function allAttachments$() {\n          return this.$.pipe(map(rxDocument => Object.entries(rxDocument.toJSON(true)._attachments)), map(entries => {\n            return entries.map(([id, attachmentData]) => {\n              return fromStorageInstanceResult(id, attachmentData, this);\n            });\n          }));\n        }\n      });\n    }\n  },\n  overwritable: {},\n  hooks: {\n    preMigrateDocument: {\n      after: preMigrateDocument\n    },\n    postMigrateDocument: {\n      after: postMigrateDocument\n    }\n  }\n};\nexport * from \"./attachments-utils.js\";\n", "import { firstValueFrom, filter } from 'rxjs';\nimport { getChangedDocumentsSince, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, batchArray, clone, ensureNotFalsy, getHeightOfRevision, PROMISE_RESOLVE_FALSE } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { resolveConflictError } from \"./conflicts.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'up');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'up', state.input.initialCheckpoint.upstream);\n    }\n  }\n  var replicationHandler = state.input.replicationHandler;\n  state.streamQueue.up = state.streamQueue.up.then(() => {\n    return upstreamInitialSync().then(() => {\n      processTasks();\n    });\n  });\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var initialSyncStartTime = -1;\n  var openTasks = [];\n  var persistenceQueue = PROMISE_RESOLVE_FALSE;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  var sub = state.input.forkInstance.changeStream().subscribe(async eventBulk => {\n    // ignore writes that came from the downstream\n    if (eventBulk.context === (await state.downstreamBulkWriteFlag)) {\n      return;\n    }\n    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n    openTasks.push({\n      task: eventBulk,\n      time: timer++\n    });\n    if (!state.events.active.up.getValue()) {\n      state.events.active.up.next(true);\n    }\n    if (state.input.waitBeforePersist) {\n      return state.input.waitBeforePersist().then(() => processTasks());\n    } else {\n      return processTasks();\n    }\n  });\n  firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n  async function upstreamInitialSync() {\n    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = new Set();\n    var _loop = async function () {\n      initialSyncStartTime = timer++;\n\n      /**\n       * Throttle the calls to\n       * forkInstance.getChangedDocumentsSince() so that\n       * if the pushing to the remote is slower compared to the\n       * pulling out of forkInstance, we do not block the UI too much\n       * and have a big memory spike with all forkInstance documents.\n       */\n      if (promises.size > 3) {\n        await Promise.race(Array.from(promises));\n      }\n      var upResult = await getChangedDocumentsSince(state.input.forkInstance, state.input.pushBatchSize, lastCheckpoint);\n      if (upResult.documents.length === 0) {\n        return 1; // break\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n      var promise = persistToMaster(upResult.documents, ensureNotFalsy(lastCheckpoint));\n      promises.add(promise);\n      promise.catch().then(() => promises.delete(promise));\n    };\n    while (!state.events.canceled.getValue()) {\n      if (await _loop()) break;\n    }\n\n    /**\n     * If we had conflicts during the initial sync,\n     * it means that we likely have new writes to the fork\n     * and so we have to run the initial sync again to upstream these new writes.\n     */\n    var resolvedPromises = await Promise.all(promises);\n    var hadConflicts = resolvedPromises.find(r => !!r);\n    if (hadConflicts) {\n      await upstreamInitialSync();\n    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {\n      state.firstSyncDone.up.next(true);\n    }\n  }\n\n  /**\n   * Takes all open tasks an processes them at once.\n   */\n  function processTasks() {\n    if (state.events.canceled.getValue() || openTasks.length === 0) {\n      state.events.active.up.next(false);\n      return;\n    }\n    state.stats.up.processTasks = state.stats.up.processTasks + 1;\n    state.events.active.up.next(true);\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n      /**\n       * Merge/filter all open tasks\n       */\n      var docs = [];\n      var checkpoint = {};\n      while (openTasks.length > 0) {\n        var taskWithTime = ensureNotFalsy(openTasks.shift());\n        /**\n         * If the task came in before the last time the initial sync fetching\n         * has run, we can ignore the task because the initial sync already processed\n         * these documents.\n         */\n        if (taskWithTime.time < initialSyncStartTime) {\n          continue;\n        }\n        appendToArray(docs, taskWithTime.task.events.map(r => {\n          return r.documentData;\n        }));\n        checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n      }\n      var promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(docs, checkpoint);\n      return promise.then(() => {\n        if (openTasks.length === 0) {\n          state.events.active.up.next(false);\n        } else {\n          processTasks();\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns true if had conflicts,\n   * false if not.\n   */\n  function persistToMaster(docs, checkpoint) {\n    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[state.primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n    persistenceQueue = persistenceQueue.then(async () => {\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      var upDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(upDocsById);\n      if (docIds.length === 0) {\n        return false;\n      }\n      var assumedMasterState = await getAssumedMasterState(state, docIds);\n      var writeRowsToMaster = {};\n      var writeRowsToMasterIds = [];\n      var writeRowsToMeta = {};\n      var forkStateById = {};\n      await Promise.all(docIds.map(async docId => {\n        var fullDocData = upDocsById[docId];\n        forkStateById[docId] = fullDocData;\n        var docData = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\n        var assumedMasterDoc = assumedMasterState[docId];\n\n        /**\n         * If the master state is equal to the\n         * fork state, we can assume that the document state is already\n         * replicated.\n         */\n        if (assumedMasterDoc &&\n        // if the isResolvedConflict is correct, we do not have to compare the documents.\n        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && (await state.input.conflictHandler({\n          realMasterState: assumedMasterDoc.docData,\n          newDocumentState: docData\n        }, 'upstream-check-if-equal')).isEqual || (\n        /**\n         * If the master works with _rev fields,\n         * we use that to check if our current doc state\n         * is different from the assumedMasterDoc.\n         */\n\n        assumedMasterDoc && assumedMasterDoc.docData._rev && getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier])) {\n          return;\n        }\n        writeRowsToMasterIds.push(docId);\n        writeRowsToMaster[docId] = {\n          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n          newDocumentState: docData\n        };\n        writeRowsToMeta[docId] = await getMetaWriteRow(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined);\n      }));\n      if (writeRowsToMasterIds.length === 0) {\n        return false;\n      }\n      var writeRowsArray = Object.values(writeRowsToMaster);\n      var conflictIds = new Set();\n      var conflictsById = {};\n\n      /**\n       * To always respect the push.batchSize,\n       * we have to split the write rows into batches\n       * to ensure that replicationHandler.masterWrite() is never\n       * called with more documents than what the batchSize limits.\n       */\n      var writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n      await Promise.all(writeBatches.map(async writeBatch => {\n        // enhance docs with attachments\n        if (state.hasAttachments) {\n          await Promise.all(writeBatch.map(async row => {\n            row.newDocumentState = await fillWriteDataForAttachmentsChange(state.primaryPath, state.input.forkInstance, clone(row.newDocumentState), row.assumedMasterState);\n          }));\n        }\n        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n        masterWriteResult.forEach(conflictDoc => {\n          var id = conflictDoc[state.primaryPath];\n          conflictIds.add(id);\n          conflictsById[id] = conflictDoc;\n        });\n      }));\n      var useWriteRowsToMeta = [];\n      writeRowsToMasterIds.forEach(docId => {\n        if (!conflictIds.has(docId)) {\n          state.events.processed.up.next(writeRowsToMaster[docId]);\n          useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n        }\n      });\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      if (useWriteRowsToMeta.length > 0) {\n        await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta), 'replication-up-write-meta');\n        // TODO what happens when we have conflicts here?\n      }\n\n      /**\n       * Resolve conflicts by writing a new document\n       * state to the fork instance and the 'real' master state\n       * to the meta instance.\n       * Non-409 errors will be detected by resolveConflictError()\n       */\n      var hadConflictWrites = false;\n      if (conflictIds.size > 0) {\n        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n        var conflictWriteFork = [];\n        var conflictWriteMeta = {};\n        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {\n          var writeToMasterRow = writeRowsToMaster[docId];\n          var input = {\n            newDocumentState: writeToMasterRow.newDocumentState,\n            assumedMasterState: writeToMasterRow.assumedMasterState,\n            realMasterState\n          };\n          return resolveConflictError(state, input, forkStateById[docId]).then(async resolved => {\n            if (resolved) {\n              state.events.resolvedConflicts.next({\n                input,\n                output: resolved.output\n              });\n              conflictWriteFork.push({\n                previous: forkStateById[docId],\n                document: resolved.resolvedDoc\n              });\n              var assumedMasterDoc = assumedMasterState[docId];\n              conflictWriteMeta[docId] = await getMetaWriteRow(state, ensureNotFalsy(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined, resolved.resolvedDoc._rev);\n            }\n          });\n        }));\n        if (conflictWriteFork.length > 0) {\n          hadConflictWrites = true;\n          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, 'replication-up-write-conflict');\n          /**\n           * Errors in the forkWriteResult must not be handled\n           * because they have been caused by a write to the forkInstance\n           * in between which will anyway trigger a new upstream cycle\n           * that will then resolved the conflict again.\n           */\n          var useMetaWrites = [];\n          forkWriteResult.success.forEach(docData => {\n            var docId = docData[state.primaryPath];\n            useMetaWrites.push(conflictWriteMeta[docId]);\n          });\n          if (useMetaWrites.length > 0) {\n            await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites), 'replication-up-write-conflict-meta');\n          }\n          // TODO what to do with conflicts while writing to the metaInstance?\n        }\n      }\n\n      /**\n       * For better performance we do not await checkpoint writes,\n       * but to ensure order on parallel checkpoint writes,\n       * we have to use a queue.\n       */\n      setCheckpoint(state, 'up', useCheckpoint);\n      return hadConflictWrites;\n    }).catch(unhandledError => {\n      state.events.error.next(unhandledError);\n      return false;\n    });\n    return persistenceQueue;\n  }\n}\n", "/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\nimport { BehaviorSubject, combineLatest, filter, firstValueFrom, mergeMap, Subject } from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { clone, ensureNotFalsy, flatClone, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getCheckpointKey } from \"./checkpoint.js\";\nimport { startReplicationDownstream } from \"./downstream.js\";\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from \"./helper.js\";\nimport { startReplicationUpstream } from \"./upstream.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\nimport { getChangedDocumentsSince } from \"../rx-storage-helper.js\";\nexport * from \"./checkpoint.js\";\nexport * from \"./downstream.js\";\nexport * from \"./upstream.js\";\nexport * from \"./meta-instance.js\";\nexport * from \"./conflicts.js\";\nexport * from \"./helper.js\";\nexport function replicateRxStorageInstance(input) {\n  input = flatClone(input);\n  input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n  input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n  var checkpointKeyPromise = getCheckpointKey(input);\n  var state = {\n    primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n    hasAttachments: !!input.forkInstance.schema.attachments,\n    input,\n    checkpointKey: checkpointKeyPromise,\n    downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n    events: {\n      canceled: new BehaviorSubject(false),\n      active: {\n        down: new BehaviorSubject(true),\n        up: new BehaviorSubject(true)\n      },\n      processed: {\n        down: new Subject(),\n        up: new Subject()\n      },\n      resolvedConflicts: new Subject(),\n      error: new Subject()\n    },\n    stats: {\n      down: {\n        addNewTask: 0,\n        downstreamProcessChanges: 0,\n        downstreamResyncOnce: 0,\n        masterChangeStreamEmit: 0,\n        persistFromMaster: 0\n      },\n      up: {\n        forkChangeStreamEmit: 0,\n        persistToMaster: 0,\n        persistToMasterConflictWrites: 0,\n        persistToMasterHadConflicts: 0,\n        processTasks: 0,\n        upstreamInitialSync: 0\n      }\n    },\n    firstSyncDone: {\n      down: new BehaviorSubject(false),\n      up: new BehaviorSubject(false)\n    },\n    streamQueue: {\n      down: PROMISE_RESOLVE_VOID,\n      up: PROMISE_RESOLVE_VOID\n    },\n    checkpointQueue: PROMISE_RESOLVE_VOID,\n    lastCheckpointDoc: {}\n  };\n  startReplicationDownstream(state);\n  startReplicationUpstream(state);\n  return state;\n}\nexport function awaitRxStorageReplicationFirstInSync(state) {\n  return firstValueFrom(combineLatest([state.firstSyncDone.down.pipe(filter(v => !!v)), state.firstSyncDone.up.pipe(filter(v => !!v))])).then(() => {});\n}\nexport function awaitRxStorageReplicationInSync(replicationState) {\n  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);\n}\nexport async function awaitRxStorageReplicationIdle(state) {\n  await awaitRxStorageReplicationFirstInSync(state);\n  while (true) {\n    var {\n      down,\n      up\n    } = state.streamQueue;\n    await Promise.all([up, down]);\n    /**\n     * If the Promises have not been reassigned\n     * after awaiting them, we know that the replication\n     * is in idle state at this point in time.\n     */\n    if (down === state.streamQueue.down && up === state.streamQueue.up) {\n      return;\n    }\n  }\n}\nexport function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken,\n/**\n * If set to true,\n * the _meta.lwt from the pushed documents is kept.\n * (Used in the migration to ensure checkpoints are still valid)\n */\nkeepMeta = false) {\n  instance = getUnderlyingPersistentStorage(instance);\n  var hasAttachments = !!instance.schema.attachments;\n  var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n  var replicationHandler = {\n    masterChangeStream$: instance.changeStream().pipe(mergeMap(async eventBulk => {\n      var ret = {\n        checkpoint: eventBulk.checkpoint,\n        documents: await Promise.all(eventBulk.events.map(async event => {\n          var docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n          if (hasAttachments) {\n            docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n            /**\n             * Notice that the master never knows\n             * the client state of the document.\n             * Therefore we always send all attachments data.\n             */\n            undefined);\n          }\n          return docData;\n        }))\n      };\n      return ret;\n    })),\n    masterChangesSince(checkpoint, batchSize) {\n      return getChangedDocumentsSince(instance, batchSize, checkpoint).then(async result => {\n        return {\n          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n          documents: await Promise.all(result.documents.map(async plainDocumentData => {\n            var docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n            if (hasAttachments) {\n              docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n              /**\n               * Notice the the master never knows\n               * the client state of the document.\n               * Therefore we always send all attachments data.\n               */\n              undefined);\n            }\n            return docData;\n          }))\n        };\n      });\n    },\n    async masterWrite(rows) {\n      var rowById = {};\n      rows.forEach(row => {\n        var docId = row.newDocumentState[primaryPath];\n        rowById[docId] = row;\n      });\n      var ids = Object.keys(rowById);\n      var masterDocsStateList = await instance.findDocumentsById(ids, true);\n      var masterDocsState = new Map();\n      masterDocsStateList.forEach(doc => masterDocsState.set(doc[primaryPath], doc));\n      var conflicts = [];\n      var writeRows = [];\n      await Promise.all(Object.entries(rowById).map(async ([id, row]) => {\n        var masterState = masterDocsState.get(id);\n        if (!masterState) {\n          writeRows.push({\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n          });\n        } else if (masterState && !row.assumedMasterState) {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        } else if ((await conflictHandler({\n          realMasterState: writeDocToDocState(masterState, hasAttachments, keepMeta),\n          newDocumentState: ensureNotFalsy(row.assumedMasterState)\n        }, 'rxStorageInstanceToReplicationHandler-masterWrite')).isEqual === true) {\n          writeRows.push({\n            previous: masterState,\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n          });\n        } else {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        }\n      }));\n      if (writeRows.length > 0) {\n        var result = await instance.bulkWrite(writeRows, 'replication-master-write');\n        result.error.forEach(err => {\n          if (err.status !== 409) {\n            throw new Error('non conflict error');\n          } else {\n            conflicts.push(writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta));\n          }\n        });\n      }\n      return conflicts;\n    }\n  };\n  return replicationHandler;\n}\nexport async function cancelRxStorageReplication(replicationState) {\n  replicationState.events.canceled.next(true);\n  replicationState.events.active.up.complete();\n  replicationState.events.active.down.complete();\n  replicationState.events.processed.up.complete();\n  replicationState.events.processed.down.complete();\n  replicationState.events.resolvedConflicts.complete();\n  replicationState.events.canceled.complete();\n  await replicationState.checkpointQueue;\n}\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, map, mergeMap } from 'rxjs';\nimport { ucfirst, flatClone, promiseSeries, pluginMissing, ensureNotFalsy, getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID } from \"./plugins/utils/index.js\";\nimport { fillObjectDataBeforeInsert, createRxCollectionStorageInstance, removeCollectionStorages, ensureRxCollectionIsNotDestroyed } from \"./rx-collection-helper.js\";\nimport { createRxQuery, _getDefaultQuery } from \"./rx-query.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\nimport { DocumentCache, mapDocumentsDataToCacheDocs } from \"./doc-cache.js\";\nimport { createQueryCache, defaultCacheReplacementPolicy } from \"./query-cache.js\";\nimport { createChangeEventBuffer } from \"./change-event-buffer.js\";\nimport { runAsyncPluginHooks, runPluginHooks } from \"./hooks.js\";\nimport { createNewRxDocument, getRxDocumentConstructor } from \"./rx-document-prototype-merge.js\";\nimport { getWrappedStorageInstance, throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { defaultConflictHandler } from \"./replication-protocol/index.js\";\nimport { IncrementalWriteQueue } from \"./incremental-write.js\";\nimport { beforeDocumentUpdateWrite } from \"./rx-document.js\";\nimport { overwritable } from \"./overwritable.js\";\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var RxCollectionBase = /*#__PURE__*/function () {\n  /**\n   * Stores all 'normal' documents\n   */\n\n  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {\n    this.storageInstance = {};\n    this.timeouts = new Set();\n    this.incrementalWriteQueue = {};\n    this._incrementalUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._docCache = {};\n    this._queryCache = createQueryCache();\n    this.$ = {};\n    this.checkpoint$ = {};\n    this._changeEventBuffer = {};\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.onRemove = [];\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.internalStorageInstance = internalStorageInstance;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n    this.conflictHandler = conflictHandler;\n    _applyHookFunctions(this.asRxCollection);\n  }\n  var _proto = RxCollectionBase.prototype;\n  _proto.prepare = async function prepare() {\n    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);\n    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), result => this._runHooks('post', 'save', result));\n    var collectionEventBulks$ = this.database.eventBulks$.pipe(filter(changeEventBulk => changeEventBulk.collectionName === this.name));\n    this.$ = collectionEventBulks$.pipe(mergeMap(changeEventBulk => changeEventBulk.events));\n    this.checkpoint$ = collectionEventBulks$.pipe(map(changeEventBulk => changeEventBulk.checkpoint));\n    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n    var documentConstructor;\n    this._docCache = new DocumentCache(this.schema.primaryPath, this.$.pipe(filter(cE => !cE.isLocal)), docData => {\n      if (!documentConstructor) {\n        documentConstructor = getRxDocumentConstructor(this.asRxCollection);\n      }\n      return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\n    });\n    var listenToRemoveSub = this.database.internalStore.changeStream().pipe(filter(bulk => {\n      var key = this.name + '-' + this.schema.version;\n      var found = bulk.events.find(event => {\n        return event.documentData.context === 'collection' && event.documentData.key === key && event.operation === 'DELETE';\n      });\n      return !!found;\n    })).subscribe(async () => {\n      await this.destroy();\n      await Promise.all(this.onRemove.map(fn => fn()));\n    });\n    this._subs.push(listenToRemoveSub);\n\n    /**\n     * TODO Instead of resolving the EventBulk array here and spit it into\n     * single events, we should fully work with event bulks internally\n     * to save performance.\n     */\n    var databaseStorageToken = await this.database.storageToken;\n    var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n      var events = new Array(eventBulk.events.length);\n      var rawEvents = eventBulk.events;\n      var collectionName = this.name;\n      var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n      for (var index = 0; index < rawEvents.length; index++) {\n        var event = rawEvents[index];\n        events[index] = {\n          documentId: event.documentId,\n          collectionName,\n          isLocal: false,\n          operation: event.operation,\n          documentData: deepFreezeWhenDevMode(event.documentData),\n          previousDocumentData: deepFreezeWhenDevMode(event.previousDocumentData)\n        };\n      }\n      var changeEventBulk = {\n        id: eventBulk.id,\n        internal: false,\n        collectionName: this.name,\n        storageToken: databaseStorageToken,\n        events,\n        databaseToken: this.database.token,\n        checkpoint: eventBulk.checkpoint,\n        context: eventBulk.context,\n        endTime: eventBulk.endTime,\n        startTime: eventBulk.startTime\n      };\n      this.database.$emit(changeEventBulk);\n    });\n    this._subs.push(subDocs);\n\n    /**\n     * Resolve the conflict tasks\n     * of the RxStorageInstance\n     */\n    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe(task => {\n      this.conflictHandler(task.input, task.context).then(output => {\n        this.storageInstance.resolveConflictResultionTask({\n          id: task.id,\n          output\n        });\n      });\n    }));\n    return PROMISE_RESOLVE_VOID;\n  }\n\n  /**\n   * Manually call the cleanup function of the storage.\n   * @link https://rxdb.info/cleanup.html\n   */;\n  _proto.cleanup = function cleanup(_minimumDeletedTime) {\n    ensureRxCollectionIsNotDestroyed(this);\n    throw pluginMissing('cleanup');\n  }\n\n  // overwritten by migration-plugin\n  ;\n  _proto.migrationNeeded = function migrationNeeded() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.getMigrationState = function getMigrationState() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.startMigration = function startMigration(batchSize = 10) {\n    ensureRxCollectionIsNotDestroyed(this);\n    return this.getMigrationState().startMigration(batchSize);\n  };\n  _proto.migratePromise = function migratePromise(batchSize = 10) {\n    return this.getMigrationState().migratePromise(batchSize);\n  };\n  _proto.insert = async function insert(json) {\n    ensureRxCollectionIsNotDestroyed(this);\n    var writeResult = await this.bulkInsert([json]);\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);\n    var insertResult = ensureNotFalsy(writeResult.success[0]);\n    return insertResult;\n  };\n  _proto.bulkInsert = async function bulkInsert(docsData) {\n    ensureRxCollectionIsNotDestroyed(this);\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n    */\n    if (docsData.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var primaryPath = this.schema.primaryPath;\n\n    /**\n     * This code is a bit redundant for better performance.\n     * Instead of iterating multiple times,\n     * we directly transform the input to a write-row array.\n     */\n    var insertRows;\n    if (this.hasHooks('pre', 'insert')) {\n      insertRows = await Promise.all(docsData.map(docData => {\n        var useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n        return this._runHooks('pre', 'insert', useDocData).then(() => {\n          return {\n            document: useDocData\n          };\n        });\n      }));\n    } else {\n      insertRows = [];\n      for (var index = 0; index < docsData.length; index++) {\n        var docData = docsData[index];\n        var useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n        insertRows[index] = {\n          document: useDocData\n        };\n      }\n    }\n    var results = await this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');\n\n    // create documents\n    var rxDocuments = mapDocumentsDataToCacheDocs(this._docCache, results.success);\n    if (this.hasHooks('post', 'insert')) {\n      var docsMap = new Map();\n      insertRows.forEach(row => {\n        var doc = row.document;\n        docsMap.set(doc[primaryPath], doc);\n      });\n      await Promise.all(rxDocuments.map(doc => {\n        return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n      }));\n    }\n    return {\n      success: rxDocuments,\n      error: results.error\n    };\n  };\n  _proto.bulkRemove = async function bulkRemove(ids) {\n    ensureRxCollectionIsNotDestroyed(this);\n    var primaryPath = this.schema.primaryPath;\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n     */\n    if (ids.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var rxDocumentMap = await this.findByIds(ids).exec();\n    var docsData = [];\n    var docsMap = new Map();\n    Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n      var data = rxDocument.toMutableJSON(true);\n      docsData.push(data);\n      docsMap.set(rxDocument.primary, data);\n    });\n    await Promise.all(docsData.map(doc => {\n      var primary = doc[this.schema.primaryPath];\n      return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n    }));\n    var removeDocs = docsData.map(doc => {\n      var writeDoc = flatClone(doc);\n      writeDoc._deleted = true;\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    var results = await this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');\n    var successIds = results.success.map(d => d[primaryPath]);\n\n    // run hooks\n    await Promise.all(successIds.map(id => {\n      return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));\n    }));\n    var rxDocuments = successIds.map(id => getFromMapOrThrow(rxDocumentMap, id));\n    return {\n      success: rxDocuments,\n      error: results.error\n    };\n  }\n\n  /**\n   * same as bulkInsert but overwrites existing document with same primary\n   */;\n  _proto.bulkUpsert = async function bulkUpsert(docsData) {\n    ensureRxCollectionIsNotDestroyed(this);\n    var insertData = [];\n    var useJsonByDocId = new Map();\n    docsData.forEach(docData => {\n      var useJson = fillObjectDataBeforeInsert(this.schema, docData);\n      var primary = useJson[this.schema.primaryPath];\n      if (!primary) {\n        throw newRxError('COL3', {\n          primaryPath: this.schema.primaryPath,\n          data: useJson,\n          schema: this.schema.jsonSchema\n        });\n      }\n      useJsonByDocId.set(primary, useJson);\n      insertData.push(useJson);\n    });\n    var insertResult = await this.bulkInsert(insertData);\n    var success = insertResult.success.slice(0);\n    var error = [];\n\n    // update the ones that existed already\n    await Promise.all(insertResult.error.map(async err => {\n      if (err.status !== 409) {\n        error.push(err);\n      } else {\n        var id = err.documentId;\n        var writeData = getFromMapOrThrow(useJsonByDocId, id);\n        var docDataInDb = ensureNotFalsy(err.documentInDb);\n        var doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\n        var newDoc = await doc.incrementalModify(() => writeData);\n        success.push(newDoc);\n      }\n    }));\n    return {\n      error,\n      success\n    };\n  }\n\n  /**\n   * same as insert but overwrites existing document with same primary\n   */;\n  _proto.upsert = async function upsert(json) {\n    ensureRxCollectionIsNotDestroyed(this);\n    var bulkResult = await this.bulkUpsert([json]);\n    throwIfIsStorageWriteError(this.asRxCollection, json[this.schema.primaryPath], json, bulkResult.error[0]);\n    return bulkResult.success[0];\n  }\n\n  /**\n   * upserts to a RxDocument, uses incrementalModify if document already exists\n   */;\n  _proto.incrementalUpsert = function incrementalUpsert(json) {\n    ensureRxCollectionIsNotDestroyed(this);\n    var useJson = fillObjectDataBeforeInsert(this.schema, json);\n    var primary = useJson[this.schema.primaryPath];\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    }\n\n    // ensure that it won't try 2 parallel runs\n    var queue = this._incrementalUpsertQueues.get(primary);\n    if (!queue) {\n      queue = PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {\n      if (!wasInserted.inserted) {\n        return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n      } else {\n        return wasInserted.doc;\n      }\n    });\n    this._incrementalUpsertQueues.set(primary, queue);\n    return queue;\n  };\n  _proto.find = function find(queryObj) {\n    ensureRxCollectionIsNotDestroyed(this);\n    if (typeof queryObj === 'string') {\n      throw newRxError('COL5', {\n        queryObj\n      });\n    }\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n  _proto.findOne = function findOne(queryObj) {\n    ensureRxCollectionIsNotDestroyed(this);\n\n    // TODO move this check to dev-mode plugin\n    if (typeof queryObj === 'number' || Array.isArray(queryObj)) {\n      throw newRxTypeError('COL6', {\n        queryObj\n      });\n    }\n    var query;\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          [this.schema.primaryPath]: queryObj\n        },\n        limit: 1\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery();\n      }\n\n      // cannot have limit on findOne queries because it will be overwritten\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n      queryObj = flatClone(queryObj);\n      queryObj.limit = 1;\n      query = createRxQuery('findOne', queryObj, this);\n    }\n    return query;\n  };\n  _proto.count = function count(queryObj) {\n    ensureRxCollectionIsNotDestroyed(this);\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('count', queryObj, this);\n    return query;\n  }\n\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */;\n  _proto.findByIds = function findByIds(ids) {\n    ensureRxCollectionIsNotDestroyed(this);\n    var mangoQuery = {\n      selector: {\n        [this.schema.primaryPath]: {\n          $in: ids.slice(0)\n        }\n      }\n    };\n    var query = createRxQuery('findByIds', mangoQuery, this);\n    return query;\n  }\n\n  /**\n   * Export collection to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON() {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.insertCRDT = function insertCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  }\n\n  /**\n   * HOOKS\n   */;\n  _proto.addHook = function addHook(when, key, fun, parallel = false) {\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key\n      });\n    }\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when,\n        key,\n        parallel\n      });\n    }\n\n    // bind this-scope to hook-function\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n  _proto.getHooks = function getHooks(when, key) {\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n    return this.hooks[key][when];\n  };\n  _proto.hasHooks = function hasHooks(when, key) {\n    /**\n     * Performance shortcut\n     * so that we not have to build the empty object.\n     */\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return false;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return false;\n    }\n    return hooks.series.length > 0 || hooks.parallel.length > 0;\n  };\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return PROMISE_RESOLVE_VOID;\n    }\n\n    // run parallel: false\n    var tasks = hooks.series.map(hook => () => hook(data, instance));\n    return promiseSeries(tasks)\n    // run parallel: true\n    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));\n  }\n\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */;\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    if (!this.hasHooks(when, key)) {\n      return;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(hook => hook(data, instance));\n  }\n\n  /**\n   * Returns a promise that resolves after the given time.\n   * Ensures that is properly cleans up when the collection is destroyed\n   * so that no running timeouts prevent the exit of the JavaScript process.\n   */;\n  _proto.promiseWait = function promiseWait(time) {\n    var ret = new Promise(res => {\n      var timeout = setTimeout(() => {\n        this.timeouts.delete(timeout);\n        res();\n      }, time);\n      this.timeouts.add(timeout);\n    });\n    return ret;\n  };\n  _proto.destroy = async function destroy() {\n    if (this.destroyed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n    await Promise.all(this.onDestroy.map(fn => fn()));\n\n    /**\n     * Settings destroyed = true\n     * must be the first thing to do,\n     * so for example the replication can directly stop\n     * instead of sending requests to a closed storage.\n     */\n    this.destroyed = true;\n    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.destroy();\n    }\n    /**\n     * First wait until the whole database is idle.\n     * This ensures that the storage does not get closed\n     * while some operation is running.\n     * It is important that we do not intercept a running call\n     * because it might lead to undefined behavior like when a doc is written\n     * but the change is not added to the changes collection.\n     */\n    return this.database.requestIdlePromise().then(() => this.storageInstance.close()).then(() => {\n      /**\n       * Unsubscribing must be done AFTER the storageInstance.close()\n       * Because the conflict handling is part of the subscriptions and\n       * otherwise there might be open conflicts to be resolved which\n       * will then stuck and never resolve.\n       */\n      this._subs.forEach(sub => sub.unsubscribe());\n      delete this.database.collections[this.name];\n      return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n    });\n  }\n\n  /**\n   * remove all data of the collection\n   */;\n  _proto.remove = async function remove() {\n    await this.destroy();\n    await Promise.all(this.onRemove.map(fn => fn()));\n    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.password, this.database.hashFunction);\n  };\n  return _createClass(RxCollectionBase, [{\n    key: \"insert$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'INSERT'));\n    }\n  }, {\n    key: \"update$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'UPDATE'));\n    }\n  }, {\n    key: \"remove$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'DELETE'));\n    }\n\n    // defaults\n\n    /**\n     * When the collection is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n    */\n  }, {\n    key: \"asRxCollection\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(key => {\n    HOOKS_WHEN.map(when => {\n      var fnName = when + ucfirst(key);\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\nfunction _incrementalUpsertUpdate(doc, json) {\n  return doc.incrementalModify(_innerDoc => {\n    return json;\n  });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  /**\n   * Optimisation shortcut,\n   * first try to find the document in the doc-cache\n   */\n  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n  if (docDataFromCache) {\n    return Promise.resolve({\n      doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\n      inserted: false\n    });\n  }\n  return rxCollection.findOne(primary).exec().then(doc => {\n    if (!doc) {\n      return rxCollection.insert(json).then(newDoc => ({\n        doc: newDoc,\n        inserted: true\n      }));\n    } else {\n      return {\n        doc,\n        inserted: false\n      };\n    }\n  });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection({\n  database,\n  name,\n  schema,\n  instanceCreationOptions = {},\n  migrationStrategies = {},\n  autoMigrate = true,\n  statics = {},\n  methods = {},\n  attachments = {},\n  options = {},\n  localDocuments = false,\n  cacheReplacementPolicy = defaultCacheReplacementPolicy,\n  conflictHandler = defaultConflictHandler\n}) {\n  var storageInstanceCreationParams = {\n    databaseInstanceToken: database.token,\n    databaseName: database.name,\n    collectionName: name,\n    schema: schema.jsonSchema,\n    options: instanceCreationOptions,\n    multiInstance: database.multiInstance,\n    password: database.password,\n    devMode: overwritable.isDevMode()\n  };\n  runPluginHooks('preCreateRxStorageInstance', storageInstanceCreationParams);\n  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then(storageInstance => {\n    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);\n    return collection.prepare().then(() => {\n      // ORM add statics\n      Object.entries(statics).forEach(([funName, fun]) => {\n        Object.defineProperty(collection, funName, {\n          get: () => fun.bind(collection)\n        });\n      });\n      var ret = PROMISE_RESOLVE_VOID;\n      if (autoMigrate && collection.schema.version !== 0) {\n        ret = collection.migratePromise();\n      }\n      return ret;\n    }).then(() => {\n      runPluginHooks('createRxCollection', {\n        collection,\n        creator: {\n          name,\n          schema,\n          storageInstance,\n          instanceCreationOptions,\n          migrationStrategies,\n          methods,\n          attachments,\n          options,\n          cacheReplacementPolicy,\n          localDocuments,\n          statics\n        }\n      });\n      return collection;\n    })\n    /**\n     * If the collection creation fails,\n     * we yet have to close the storage instances.\n     */.catch(err => {\n      return storageInstance.close().then(() => Promise.reject(err));\n    });\n  });\n}\nexport function isRxCollection(obj) {\n  return obj instanceof RxCollectionBase;\n}\n", "/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n    _tryIdleCall(this);\n  },\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n    this.lock();\n    var maybePromise;\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n        throw err;\n      });\n    }\n  },\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n      resolve();\n    };\n    prom._manRes = resolveFromOutside;\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n    this._iC.add(prom);\n    _tryIdleCall(this);\n    return prom;\n  },\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n    this._hPM.set(handle, promise);\n    this._pHM.set(promise, handle);\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n    this.cancelIdlePromise(promise);\n  },\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n    this._qC = 0;\n    this._iC.clear();\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n  var iterator = idleQueue._iC.values();\n  var oldestPromise = iterator.next().value;\n  oldestPromise._manRes(); // try to call the next tick\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n    idleQueue._hPM[\"delete\"](handle);\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n  idleQueue._iC[\"delete\"](promise);\n}\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n      _resolveOneIdleCall(idleQueue);\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { IdleQueue } from 'custom-idle-queue';\nimport { pluginMissing, flatClone, PROMISE_RESOLVE_FALSE, randomCouchString, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, defaultHashSha256, RXDB_VERSION } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { createRxSchema } from \"./rx-schema.js\";\nimport { runPluginHooks, runAsyncPluginHooks } from \"./hooks.js\";\nimport { Subject } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nimport { createRxCollection } from \"./rx-collection.js\";\nimport { flatCloneDocWithMeta, getSingleDocument, getWrappedStorageInstance, INTERNAL_STORAGE_NAME } from \"./rx-storage-helper.js\";\nimport { ObliviousSet } from 'oblivious-set';\nimport { ensureStorageTokenDocumentExists, getAllCollectionDocuments, getPrimaryKeyOfInternalDocument, INTERNAL_CONTEXT_COLLECTION, INTERNAL_STORE_SCHEMA, _collectionNamePrimary } from \"./rx-database-internal-store.js\";\nimport { removeCollectionStorages } from \"./rx-collection-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\n/**\n * stores the used database names+storage names\n * so we can throw when the same database is created more then once.\n */\nvar USED_DATABASE_NAMES = new Set();\nvar DB_COUNT = 0;\nexport var RxDatabaseBase = /*#__PURE__*/function () {\n  /**\n   * Contains all known non-closed storage instances\n   * that belong to this database.\n   * Used in plugins and unit tests.\n   */\n\n  function RxDatabaseBase(name,\n  /**\n   * Uniquely identifies the instance\n   * of this RxDatabase.\n   */\n  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},\n  /**\n   * Stores information documents about the collections of the database\n   */\n  internalStore, hashFunction, cleanupPolicy, allowSlowCount, reactivity) {\n    this.idleQueue = new IdleQueue();\n    this.rxdbVersion = RXDB_VERSION;\n    this.storageInstances = new Set();\n    this._subs = [];\n    this.startupErrors = [];\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.collections = {};\n    this.states = {};\n    this.eventBulks$ = new Subject();\n    this.observable$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => changeEventBulk.events));\n    this.storageToken = PROMISE_RESOLVE_FALSE;\n    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;\n    this.emittedEventBulkIds = new ObliviousSet(60 * 1000);\n    this.name = name;\n    this.token = token;\n    this.storage = storage;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.password = password;\n    this.multiInstance = multiInstance;\n    this.eventReduce = eventReduce;\n    this.options = options;\n    this.internalStore = internalStore;\n    this.hashFunction = hashFunction;\n    this.cleanupPolicy = cleanupPolicy;\n    this.allowSlowCount = allowSlowCount;\n    this.reactivity = reactivity;\n    DB_COUNT++;\n\n    /**\n     * In the dev-mode, we create a pseudoInstance\n     * to get all properties of RxDatabase and ensure they do not\n     * conflict with the collection names etc.\n     * So only if it is not pseudoInstance,\n     * we have all values to prepare a real RxDatabase.\n     *\n     * TODO this is ugly, we should use a different way in the dev-mode\n     * so that all non-dev-mode code can be cleaner.\n     */\n    if (this.name !== 'pseudoInstance') {\n      /**\n       * Wrap the internal store\n       * to ensure that calls to it also end up in\n       * calculation of the idle state and the hooks.\n       */\n      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);\n\n      /**\n       * Start writing the storage token.\n       * Do not await the creation because it would run\n       * in a critical path that increases startup time.\n       *\n       * Writing the token takes about 20 milliseconds\n       * even on a fast adapter, so this is worth it.\n       */\n      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch(err => this.startupErrors.push(err));\n      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));\n    }\n  }\n  var _proto = RxDatabaseBase.prototype;\n  _proto.getReactivityFactory = function getReactivityFactory() {\n    if (!this.reactivity) {\n      throw newRxError('DB14', {\n        database: this.name\n      });\n    }\n    return this.reactivity;\n  }\n\n  /**\n   * Because having unhandled exceptions would fail,\n   * we have to store the async errors of the constructor here\n   * so we can throw them later.\n   */\n\n  /**\n   * When the database is destroyed,\n   * these functions will be called an awaited.\n   * Used to automatically clean up stuff that\n   * belongs to this collection.\n   */\n\n  /**\n   * Unique token that is stored with the data.\n   * Used to detect if the dataset has been deleted\n   * and if two RxDatabase instances work on the same dataset or not.\n   *\n   * Because reading and writing the storageToken runs in the hot path\n   * of database creation, we do not await the storageWrites but instead\n   * work with the promise when we need the value.\n   */\n\n  /**\n   * Stores the whole state of the internal storage token document.\n   * We need this in some plugins.\n   */\n\n  /**\n   * Contains the ids of all event bulks that have been emitted\n   * by the database.\n   * Used to detect duplicates that come in again via BroadcastChannel\n   * or other streams.\n   * TODO instead of having this here, we should add a test to ensure each RxStorage\n   * behaves equal and does never emit duplicate eventBulks.\n   */;\n  /**\n   * This is the main handle-point for all change events\n   * ChangeEvents created by this instance go:\n   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n   * ChangeEvents created by other instances go:\n   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n   */\n  _proto.$emit = function $emit(changeEventBulk) {\n    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n      return;\n    }\n    this.emittedEventBulkIds.add(changeEventBulk.id);\n\n    // emit into own stream\n    this.eventBulks$.next(changeEventBulk);\n  }\n\n  /**\n   * removes the collection-doc from the internalStore\n   */;\n  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {\n    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));\n    if (!doc) {\n      throw newRxError('SNH', {\n        name,\n        schema\n      });\n    }\n    var writeDoc = flatCloneDocWithMeta(doc);\n    writeDoc._deleted = true;\n    await this.internalStore.bulkWrite([{\n      document: writeDoc,\n      previous: doc\n    }], 'rx-database-remove-collection');\n  }\n\n  /**\n   * creates multiple RxCollections at once\n   * to be much faster by saving db txs and doing stuff in bulk-operations\n   * This function is not called often, but mostly in the critical path at the initial page load\n   * So it must be as fast as possible.\n   */;\n  _proto.addCollections = async function addCollections(collectionCreators) {\n    var jsonSchemas = {};\n    var schemas = {};\n    var bulkPutDocs = [];\n    var useArgsByCollectionName = {};\n    await Promise.all(Object.entries(collectionCreators).map(async ([name, args]) => {\n      var collectionName = name;\n      var rxJsonSchema = args.schema;\n      jsonSchemas[collectionName] = rxJsonSchema;\n      var schema = createRxSchema(rxJsonSchema, this.hashFunction);\n      schemas[collectionName] = schema;\n\n      // collection already exists\n      if (this.collections[name]) {\n        throw newRxError('DB3', {\n          name\n        });\n      }\n      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n      var collectionDocData = {\n        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),\n        key: collectionNameWithVersion,\n        context: INTERNAL_CONTEXT_COLLECTION,\n        data: {\n          name: collectionName,\n          schemaHash: await schema.hash,\n          schema: schema.jsonSchema,\n          version: schema.version,\n          connectedStorages: []\n        },\n        _deleted: false,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n      };\n      bulkPutDocs.push({\n        document: collectionDocData\n      });\n      var useArgs = Object.assign({}, args, {\n        name: collectionName,\n        schema,\n        database: this\n      });\n\n      // run hooks\n      var hookData = flatClone(args);\n      hookData.database = this;\n      hookData.name = name;\n      runPluginHooks('preCreateRxCollection', hookData);\n      useArgs.conflictHandler = hookData.conflictHandler;\n      useArgsByCollectionName[collectionName] = useArgs;\n    }));\n    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');\n    await ensureNoStartupErrors(this);\n    await Promise.all(putDocsResult.error.map(async error => {\n      if (error.status !== 409) {\n        throw newRxError('DB12', {\n          database: this.name,\n          writeError: error\n        });\n      }\n      var docInDb = ensureNotFalsy(error.documentInDb);\n      var collectionName = docInDb.data.name;\n      var schema = schemas[collectionName];\n      // collection already exists but has different schema\n      if (docInDb.data.schemaHash !== (await schema.hash)) {\n        throw newRxError('DB6', {\n          database: this.name,\n          collection: collectionName,\n          previousSchemaHash: docInDb.data.schemaHash,\n          schemaHash: await schema.hash,\n          previousSchema: docInDb.data.schema,\n          schema: ensureNotFalsy(jsonSchemas[collectionName])\n        });\n      }\n    }));\n    var ret = {};\n    await Promise.all(Object.keys(collectionCreators).map(async collectionName => {\n      var useArgs = useArgsByCollectionName[collectionName];\n      var collection = await createRxCollection(useArgs);\n      ret[collectionName] = collection;\n\n      // set as getter to the database\n      this.collections[collectionName] = collection;\n      if (!this[collectionName]) {\n        Object.defineProperty(this, collectionName, {\n          get: () => this.collections[collectionName]\n        });\n      }\n    }));\n    return ret;\n  }\n\n  /**\n   * runs the given function between idleQueue-locking\n   */;\n  _proto.lockedRun = function lockedRun(fn) {\n    return this.idleQueue.wrapCall(fn);\n  };\n  _proto.requestIdlePromise = function requestIdlePromise() {\n    return this.idleQueue.requestIdlePromise();\n  }\n\n  /**\n   * Export database to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON(_collections) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.addState = function addState(_name) {\n    throw pluginMissing('state');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n   * since data could be encrypted.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.backup = function backup(_options) {\n    throw pluginMissing('backup');\n  };\n  _proto.leaderElector = function leaderElector() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.isLeader = function isLeader() {\n    throw pluginMissing('leader-election');\n  }\n  /**\n   * returns a promise which resolves when the instance becomes leader\n   */;\n  _proto.waitForLeadership = function waitForLeadership() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.migrationStates = function migrationStates() {\n    throw pluginMissing('migration-schema');\n  }\n\n  /**\n   * destroys the database-instance and all collections\n   */;\n  _proto.destroy = async function destroy() {\n    if (this.destroyed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    // settings destroyed = true must be the first thing to do.\n    this.destroyed = true;\n    await runAsyncPluginHooks('preDestroyRxDatabase', this);\n    /**\n     * Complete the event stream\n     * to stop all subscribers who forgot to unsubscribe.\n     */\n    this.eventBulks$.complete();\n    DB_COUNT--;\n    this._subs.map(sub => sub.unsubscribe());\n\n    /**\n     * Destroying the pseudo instance will throw\n     * because stuff is missing\n     * TODO we should not need the pseudo instance on runtime.\n     * we should generate the property list on build time.\n     */\n    if (this.name === 'pseudoInstance') {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    /**\n     * First wait until the database is idle\n     */\n    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map(fn => fn())))\n    // destroy all collections\n    .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.destroy())))\n    // destroy internal storage instances\n    .then(() => this.internalStore.close())\n    // remove combination from USED_COMBINATIONS-map\n    .then(() => USED_DATABASE_NAMES.delete(this.storage.name + '|' + this.name)).then(() => true);\n  }\n\n  /**\n   * deletes the database and its stored data.\n   * Returns the names of all removed collections.\n   */;\n  _proto.remove = function remove() {\n    return this.destroy().then(() => removeRxDatabase(this.name, this.storage, this.password));\n  };\n  return _createClass(RxDatabaseBase, [{\n    key: \"$\",\n    get: function () {\n      return this.observable$;\n    }\n  }, {\n    key: \"asRxDatabase\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * checks if an instance with same name and storage already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(name, storage) {\n  var key = storage.name + '|' + name;\n  if (!USED_DATABASE_NAMES.has(key)) {\n    return;\n  } else {\n    throw newRxError('DB8', {\n      name,\n      storage: storage.name,\n      link: 'https://rxdb.info/rx-database.html#ignoreduplicate'\n    });\n  }\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {\n  var internalStore = await storage.createStorageInstance({\n    databaseInstanceToken,\n    databaseName,\n    collectionName: INTERNAL_STORAGE_NAME,\n    schema: INTERNAL_STORE_SCHEMA,\n    options,\n    multiInstance,\n    password,\n    devMode: overwritable.isDevMode()\n  });\n  return internalStore;\n}\nexport function createRxDatabase({\n  storage,\n  instanceCreationOptions,\n  name,\n  password,\n  multiInstance = true,\n  eventReduce = true,\n  ignoreDuplicate = false,\n  options = {},\n  cleanupPolicy,\n  allowSlowCount = false,\n  localDocuments = false,\n  hashFunction = defaultHashSha256,\n  reactivity\n}) {\n  runPluginHooks('preCreateRxDatabase', {\n    storage,\n    instanceCreationOptions,\n    name,\n    password,\n    multiInstance,\n    eventReduce,\n    ignoreDuplicate,\n    options,\n    localDocuments\n  });\n  // check if combination already used\n  if (!ignoreDuplicate) {\n    throwIfDatabaseNameUsed(name, storage);\n  }\n  USED_DATABASE_NAMES.add(storage.name + '|' + name);\n  var databaseInstanceToken = randomCouchString(10);\n  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password)\n  /**\n   * Creating the internal store might fail\n   * if some RxStorage wrapper is used that does some checks\n   * and then throw.\n   * In that case we have to properly clean up the database.\n   */.catch(err => {\n    USED_DATABASE_NAMES.delete(storage.name + '|' + name);\n    throw err;\n  }).then(storageInstance => {\n    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount, reactivity);\n    return runAsyncPluginHooks('createRxDatabase', {\n      database: rxDatabase,\n      creator: {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n      }\n    }).then(() => rxDatabase);\n  });\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport async function removeRxDatabase(databaseName, storage, password) {\n  var databaseInstanceToken = randomCouchString(10);\n  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false, password);\n  var collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);\n  var collectionNames = new Set();\n  collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n  var removedCollectionNames = Array.from(collectionNames);\n  await Promise.all(removedCollectionNames.map(collectionName => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName, password)));\n  await runAsyncPluginHooks('postRemoveRxDatabase', {\n    databaseName,\n    storage\n  });\n  await dbInternalsStorageInstance.remove();\n  return removedCollectionNames;\n}\nexport function isRxDatabase(obj) {\n  return obj instanceof RxDatabaseBase;\n}\nexport function dbCount() {\n  return DB_COUNT;\n}\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport async function isRxDatabaseFirstTimeInstantiated(database) {\n  var tokenDoc = await database.storageTokenDocument;\n  return tokenDoc.data.instanceToken === database.token;\n}\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nexport async function ensureNoStartupErrors(rxDatabase) {\n  await rxDatabase.storageToken;\n  if (rxDatabase.startupErrors[0]) {\n    throw rxDatabase.startupErrors[0];\n  }\n}\n", "/**\n * this handles how plugins are added to rxdb\n * basically it changes the internal prototypes\n * by passing them to the plugins-functions\n */\nimport { RxSchema } from \"./rx-schema.js\";\nimport { basePrototype as RxDocumentPrototype } from \"./rx-document.js\";\nimport { RxQueryBase } from \"./rx-query.js\";\nimport { RxCollectionBase } from \"./rx-collection.js\";\nimport { RxDatabaseBase } from \"./rx-database.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { HOOKS, runPluginHooks } from \"./hooks.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\n\n/**\n * prototypes that can be manipulated with a plugin\n */\nvar PROTOTYPES = {\n  RxSchema: RxSchema.prototype,\n  RxDocument: RxDocumentPrototype,\n  RxQuery: RxQueryBase.prototype,\n  RxCollection: RxCollectionBase.prototype,\n  RxDatabase: RxDatabaseBase.prototype\n};\nvar ADDED_PLUGINS = new Set();\nvar ADDED_PLUGIN_NAMES = new Set();\n\n/**\n * Add a plugin to the RxDB library.\n * Plugins are added globally and cannot be removed.\n */\nexport function addRxPlugin(plugin) {\n  runPluginHooks('preAddRxPlugin', {\n    plugin,\n    plugins: ADDED_PLUGINS\n  });\n\n  // do nothing if added before\n  if (ADDED_PLUGINS.has(plugin)) {\n    return;\n  } else {\n    // ensure no other plugin with the same name was already added\n    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {\n      throw newRxError('PL3', {\n        name: plugin.name,\n        plugin\n      });\n    }\n    ADDED_PLUGINS.add(plugin);\n    ADDED_PLUGIN_NAMES.add(plugin.name);\n  }\n\n  /**\n   * To identify broken configurations,\n   * we only allow RxDB plugins to be passed into addRxPlugin().\n   */\n  if (!plugin.rxdb) {\n    throw newRxTypeError('PL1', {\n      plugin\n    });\n  }\n  if (plugin.init) {\n    plugin.init();\n  }\n\n  // prototype-overwrites\n  if (plugin.prototypes) {\n    Object.entries(plugin.prototypes).forEach(([name, fun]) => {\n      return fun(PROTOTYPES[name]);\n    });\n  }\n  // overwritable-overwrites\n  if (plugin.overwritable) {\n    Object.assign(overwritable, plugin.overwritable);\n  }\n  // extend-hooks\n  if (plugin.hooks) {\n    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {\n      if (hooksObj.after) {\n        HOOKS[name].push(hooksObj.after);\n      }\n      if (hooksObj.before) {\n        HOOKS[name].unshift(hooksObj.before);\n      }\n    });\n  }\n}\n", "/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n *\n * We really often have to craft an index string for a given document.\n * Performance of everything in this file is very important\n * which is why the code sometimes looks strange.\n * Run performance tests before and after you touch anything here!\n */\n\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nimport { ensureNotFalsy, objectPathMonad } from \"./plugins/utils/index.js\";\nimport { INDEX_MAX, INDEX_MIN } from \"./query-planner.js\";\n\n/**\n * Prepare all relevant information\n * outside of the returned function\n * from getIndexableStringMonad()\n * to save performance when the returned\n * function is called many times.\n */\n\nexport function getIndexMeta(schema, index) {\n  var fieldNameProperties = index.map(fieldName => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    if (!schemaPart) {\n      throw new Error('not in schema: ' + fieldName);\n    }\n    var type = schemaPart.type;\n    var parsedLengths;\n    if (type === 'number' || type === 'integer') {\n      parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n    }\n    var getValue = objectPathMonad(fieldName);\n    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\n    var getIndexStringPart;\n    if (type === 'string') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        if (!fieldValue) {\n          fieldValue = '';\n        }\n        return fieldValue.padEnd(maxLength, ' ');\n      };\n    } else if (type === 'boolean') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return fieldValue ? '1' : '0';\n      };\n    } else {\n      // number\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return getNumberIndexString(parsedLengths, fieldValue);\n      };\n    }\n    var ret = {\n      fieldName,\n      schemaPart,\n      parsedLengths,\n      getValue,\n      getIndexStringPart\n    };\n    return ret;\n  });\n  return fieldNameProperties;\n}\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var fieldNamePropertiesAmount = fieldNameProperties.length;\n  var indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\n\n  /**\n   * @hotPath Performance of this function is very critical!\n   */\n  var ret = function (docData) {\n    var str = '';\n    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {\n      str += indexPartsFunctions[i](docData);\n    }\n    return str;\n  };\n  return ret;\n}\nexport function getStringLengthOfIndexNumber(schemaPart) {\n  var minimum = Math.floor(schemaPart.minimum);\n  var maximum = Math.ceil(schemaPart.maximum);\n  var multipleOf = schemaPart.multipleOf;\n  var valueSpan = maximum - minimum;\n  var nonDecimals = valueSpan.toString().length;\n  var multipleOfParts = multipleOf.toString().split('.');\n  var decimals = 0;\n  if (multipleOfParts.length > 1) {\n    decimals = multipleOfParts[1].length;\n  }\n  return {\n    minimum,\n    maximum,\n    nonDecimals,\n    decimals,\n    roundedMinimum: minimum\n  };\n}\nexport function getIndexStringLength(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var length = 0;\n  fieldNameProperties.forEach(props => {\n    var schemaPart = props.schemaPart;\n    var type = schemaPart.type;\n    if (type === 'string') {\n      length += schemaPart.maxLength;\n    } else if (type === 'boolean') {\n      length += 1;\n    } else {\n      var parsedLengths = props.parsedLengths;\n      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n    }\n  });\n  return length;\n}\nexport function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {\n  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n  // we can safely trim here because the primary key is not allowed to start or end with a space char.\n  var primaryKey = paddedPrimaryKey.trim();\n  return primaryKey;\n}\nexport function getNumberIndexString(parsedLengths, fieldValue) {\n  /**\n   * Ensure that the given value is in the boundaries\n   * of the schema, otherwise it would create a broken index string.\n   * This can happen for example if you have a minimum of 0\n   * and run a query like\n   * selector {\n   *  numField: { $gt: -1000 }\n   * }\n   */\n  if (typeof fieldValue === 'undefined') {\n    fieldValue = 0;\n  }\n  if (fieldValue < parsedLengths.minimum) {\n    fieldValue = parsedLengths.minimum;\n  }\n  if (fieldValue > parsedLengths.maximum) {\n    fieldValue = parsedLengths.maximum;\n  }\n  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n  if (parsedLengths.decimals > 0) {\n    var splitByDecimalPoint = fieldValue.toString().split('.');\n    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n  }\n  return str;\n}\nexport function getStartIndexStringFromLowerBound(schema, index, lowerBound) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = lowerBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n        if (typeof bound === 'string') {\n          str += bound.padEnd(maxLength, ' ');\n        } else {\n          // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n          str += ''.padEnd(maxLength, ' ');\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += '0';\n        } else if (bound === INDEX_MIN) {\n          str += '0';\n        } else if (bound === INDEX_MAX) {\n          str += '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MIN) {\n          var fillChar = '0';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else if (bound === INDEX_MAX) {\n          str += getNumberIndexString(parsedLengths, parsedLengths.maximum);\n        } else {\n          var add = getNumberIndexString(parsedLengths, bound);\n          str += add;\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\nexport function getStartIndexStringFromUpperBound(schema, index, upperBound) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = upperBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n        if (typeof bound === 'string' && bound !== INDEX_MAX) {\n          str += bound.padEnd(maxLength, ' ');\n        } else if (bound === INDEX_MIN) {\n          str += ''.padEnd(maxLength, ' ');\n        } else {\n          str += ''.padEnd(maxLength, INDEX_MAX);\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MAX) {\n          var fillChar = '9';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else if (bound === INDEX_MIN) {\n          var _fillChar = '0';\n          str += _fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else {\n          str += getNumberIndexString(parsedLengths, bound);\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\n\n/**\n * Used in storages where it is not possible\n * to define inclusiveEnd/inclusiveStart\n */\nexport function changeIndexableStringByOneQuantum(str, direction) {\n  var lastChar = str.slice(-1);\n  var charCode = lastChar.charCodeAt(0);\n  charCode = charCode + direction;\n  var withoutLastChar = str.slice(0, -1);\n  return withoutLastChar + String.fromCharCode(charCode);\n}\n"],
  "mappings": "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",
  "names": ["RxSchema", "getDocumentPrototype", "IncrementalWriteQueue", "item", "ChangeEventBuffer", "RxAttachment", "RxCollectionBase", "docData", "useDocData", "promiseWait", "IdleQueue", "requestIdlePromise", "resolveFromOutside", "RxDatabaseBase", "requestIdlePromise"]
}
